#!/usr/bin/perl -w

use DBI;
use POSIX;
use Getopt::Long;
use Date::Parse;

use constant MASTERDB => 1;
use constant AGENTDB  => 2;
use constant HUMAN    => 3;
use constant COMPUTER => 4;

use constant HUMAN_DATE => "%Y-%m-%d %H:%M:%S";

our %ACTION_RESULT = (
	0 => 'succeeded',
	1 => 'FAILED',
	2 => 'skipped'
);

our $db = DBI->connect('dbi:SQLite:dbname=local/db/master.db') or
	die "Database connection failed: $!";
our $dbtype = MASTERDB;

#$db = DBI->connect('dbi:SQLite:dbname=db/agent.db') or
#	die "Database connection failed: $!";
#$dbtype = AGENTDB;

our $display = HUMAN;
#$display = COMPUTER;

our %options = ();

sub help($)
{
	my $topic = shift;

	print "cwdb - Clockwork Database Reporting\n";
	print "USAGE: cwdb <command> [options]\n";
	print "\n";

	if ($topic eq "lastseen") {
		print "lastseen [options]\n";
		print "Show all hosts and when they last checked in.\n";
		print "\n";
		print "OPTIONS\n";
		print "\n";
		print "  -t             Sort the list of hosts chronologically by their\n";
		print "                 last seen date and time.  By default, the list is\n";
		print "                 sorted alphabetically.\n";
		print "\n";
		print "  -r, --reverse  Reverse the sort order.  If used with -t, hosts\n";
		print "                 that have checked in most recently will be at the\n";
		print "                 top of the list.\n";
		print "\n";

	} elsif ($topic eq "host") {
		print "host <hostname> [options]\n";
		print "Full report for a single host.\n";
		print "\n";
		print "OPTIONS\n";
		print "\n";
		print "  -a, --after    Only show job runs after a specific date / time.\n";
		print "\n";
		print "  -b, --before   Only show job runs before a specific date / time.\n";
		print "\n";
		print "  --failed       Filter the list of resources to show only resources\n";
		print "                 that Clockwork was unable to bring into compliance.\n";
		print "                 Note: --failed is mutually exclusive with --fixed\n";
		print "                       and --compliant.\n";
		print "\n";
		print "  --fixed        Show only resources that Clockwork fixed.\n";
		print "\n";
		print "  --compliant    Do not show fixed or failed resources; only display\n";
		print "                 resources that were found to be compliant already.\n";
		print "\n";
		print "  -r, --reverse  By default, job runs are sorted chronologically, with\n";
		print "                 the oldest jobs listed first.  This option reverses\n";
		print "                 the default sort order.\n";
		print "\n";
		print "  -s, --summary  Summarize job runs; do not display the individual\n";
		print "                 actions taken to enforce compliance.\n";
		print "\n";

	} elsif ($topic eq "summary") {
		print "summary\n";
		print "Compliance Summary for all hosts (last run).\n";
		print "\n";
		print "  The 'summary' command does not take any command-line arguments.\n";
		print "\n";

	} elsif ($topic eq "help") {
		print "help [topic]\n";
		print "Display cwdb help screens.\n";
		print "\n";
		print "To see command-line usage for cwdb commands, run\n";
		print "cwdb help <command-name>\n";
		print "\n";
		print "For more in-depth information, please see the man pages.\n";
		print "\n";

	} else {
		print "Commands:\n";
		print "\n";
		print "  lastseen  Show all hosts and when they last checked in.\n";
		print "  host      Full report for a single host.\n";
		print "  summary   Compliance Summary for all hosts (last run).\n";
		print "  help      Display cwdb help screens.\n";
		print "\n";
	}
}

###########################################################
#
# Master DB // Types of Reports:
#
# lastseen - All hosts and when they were last seen
#  -t             ORDER BY last_seen_at ASC (or DESC with -r)
#  --reverse, -r  reverse the sort order (ASC->DESC, DESC->ASC)
#
# host - Full report for a single host
#  --after,  -a   only show jobs after a specific date/time
#  --before, -b   only show jobs before a specific date/time
#  --failed       only show non-compliant resources / actions
#  --fixed        only show fixed resources / actions
#  --compliant    only show compliant resources (no actions)
#  --reverse, -r  ORDER BY started_at DESC
#  --summary, -s  Only show summary of resources
#
# summary - Summary for all hosts of last run (compliance)
#
#
###########################################################

sub get_options_lastseen()
{
	my ($opt_t, $opt_r);
	GetOptions(
		't'         => \$opt_t,
		'reverse|r' => \$opt_r);

	$options{SORT_BY} = $opt_t ? 'last_seen_at' : 'host_name';
	$options{ORDER}   = $opt_r ? 'DESC' : 'ASC';
}

sub get_options_host()
{
	my ($opt_after, $opt_before,
	    $opt_failed, $opt_fixed, $opt_compliant,
	    $opt_summary,
	    $opt_reverse);

	$opt_after  = '1970-01-01';
	$opt_before = '2037-12-31';
	GetOptions(
		'after|a=s'  => \$opt_after,
		'before|b=s' => \$opt_before,
		'failed'     => \$opt_failed,
		'fixed'      => \$opt_fixed,
		'compliant'  => \$opt_compliant,
		'reverse|r'  => \$opt_reverse,
		'summary|s'  => \$opt_summary
	);

	$options{FILTER} = 'all';
	if ($opt_compliant) { $options{FILTER} = 'compliant'; }
	if ($opt_fixed)     { $options{FILTER} = 'fixed';     }
	if ($opt_failed)    { $options{FILTER} = 'failed';    }

	$options{AFTER}  = str2time($opt_after);
	$options{BEFORE} = str2time($opt_before);

	$options{DISPLAY} = $opt_summary ? 'summary' : 'full';
	$options{ORDER}   = $opt_reverse ? 'DESC' : 'ASC';
}

sub get_options_summary()
{
	# no-op; not yet implemented
}

sub dispatch()
{
	my $command = shift(@ARGV) || '';

	if ($command eq "lastseen") {
		get_options_lastseen();
		lastseen();
		exit 0;

	} elsif ($command eq "host") {
		get_options_host();
		host(find_host_by_name(shift @ARGV));
		exit 0;

	} elsif ($command eq "summary") {
		get_options_summary();
		summary();
		exit 0;

	} elsif ($command eq "help") {
		help(shift(@ARGV) || '');
		exit 0;

	} else {
		print "Unknown command: '$command'\n";
		exit 1;
	}
}

sub bail($$)
{
	my $rc = shift;
	print shift() . "\n";
	exit $rc;
}

sub datef($$$)
{
	my $f = shift;
	my $t = shift;
	my $z = shift;

	return $t == 0 ? $z : strftime($f, localtime($t+0));
}

sub percf($$)
{
	my $a = shift;
	my $b = shift;
	return sprintf("%0.2f", $a * 100.0 / ($a+$b == 0 ? 1 : $b));
}

sub job_summary_line($)
{
	my $h = shift;
	$good  = $h->{compliant} + $h->{fixed};
	$bad   = $h->{noncompliant};
	$pgood = percf($good, $good + $bad);
	$pbad  = percf($bad,  $good + $bad);

	$s = "$good ($pgood%) OK";
	if ($bad > 0) { $s .= "; $bad ($pbad%) NON-COMPLIANT"; }

	return $s;
}

sub find_host_by_name($)
{
	$dbtype == MASTERDB or bail 1, "tried to find a host in an agent context";
	my $st = $db->prepare("SELECT id FROM hosts WHERE name = ?") or
		die "SQL failed: $!";

	my $name = shift;
	$st->execute($name) or die "SQL failed: $!";

	my $id = 0;
	while (@host = $st->fetchrow_array()) {
		$id = $host[0];
	}
	return $id;
}

sub lastseen()
{
	$dbtype == MASTERDB or bail 1, "lastseen makes no sense in agent context";
	my $st = $db->prepare("SELECT name, last_seen_at FROM hosts ORDER BY name ASC") or
		die "SQL failed: $!";

	if ($display == HUMAN) {
		$~=LAST_SEEN;
		$^=LAST_SEEN_TOP;
	}

	$st->execute() or die "SQL failed: $!";
	while (my @d = $st->fetchrow_array()) {
		$hostname = $d[0];
		$last_seen_at = datef(HUMAN_DATE, $d[1], "never");
		if ($display == HUMAN) { write; } else { print "$hostname $last_seen_at\n"; }
	}
}

sub summary()
{
	$dbtype == MASTERDB or bail 1, "summary makes no sense in agent context";

	my $st_h = $db->prepare("SELECT id, name FROM hosts") or
		die "SQL failed: $!";

	my $st_j = $db->prepare("SELECT id FROM jobs WHERE host_id = ? ORDER BY started_at DESC LIMIT 1") or
		die "SQL failed: $!";

	my $st_r = $db->prepare("SELECT compliant, fixed FROM resources WHERE job_id = ?") or
		die "SQL failed: $!";

	my @host;
	$st_h->execute();
	while (@host = $st_h->fetchrow_array()) {
		my %stats = (
			'compliant'    => 0,
			'noncompliant' => 0,
			'fixed'        => 0
		);

		$st_j->execute($host[0]);
		my @job = $st_j->fetchrow_array();
		if (!@job) { next; }

		$st_r->execute($job[0]);
		my @resource;
		while (@resource = $st_r->fetchrow_array()) {
			if (!$resource[0]) {
				$stats{noncompliant}++;
			} elsif ($resource[1]) {
				$stats{fixed}++;
			} else {
				$stats{compliant}++;
			}
		}

		$~ = HOST_SUMMARY;
		$^ = HOST_SUMMARY_TOP;
		$host_name = $host[1];
		$summary = job_summary_line(\%stats);
		write;
	}
}

sub host($)
{
	$dbtype == MASTERDB or bail 1, "host makes no sense in agent context";
	my $where = "WHERE host_id = ? AND started_at > ? AND started_at < ?";

	my $st_j = $db->prepare("SELECT id, started_at, ended_at, duration FROM jobs $where ORDER BY started_at $options{ORDER}") or
		die "SQL failed: $!";

	my $st_r = $db->prepare("SELECT id, type, name, compliant, fixed FROM resources WHERE job_id = ? ORDER BY sequence ASC") or
		die "SQL failed: $!";

	my $st_a = $db->prepare("SELECT summary, result FROM actions WHERE resource_id = ? ORDER BY sequence ASC") or
		die "SQL failed: $!";

	my %stats = (
		'compliant'    => 0,
		'noncompliant' => 0,
		'fixed'        => 0);

	my $host_id = shift;
	$st_j->execute($host_id, $options{AFTER}, $options{BEFORE}) or die "SQL failed: $!";
	while (@jobs = $st_j->fetchrow_array()) {
		$job_id = $jobs[0];
		if ($display == HUMAN) {
			$~ = HOST_JOB;
			$started_at = datef(HUMAN_DATE, $jobs[1], "unknown");
			#$ended_at   = datef(HUMAN_DATE, $jobs[2], "unknown");
			$duration   = $jobs[3] * 1.0 / 1000000;
			write;
		}

		$stats{compliant} = $stats{noncompliant} = $stats{fixed} = 0;
		$st_r->execute($job_id);
		while (@resource = $st_r->fetchrow_array()) {
			$resource_id = $resource[0];
			if (!$resource[3]) {
				$result = "NON-COMPLIANT";
				$stats{noncompliant}++;
				if ($options{FILTER} ne 'all' and $options{FILTER} ne 'failed') { next; }

			} elsif ($resource[4]) {
				$result = "FIXED";
				$stats{fixed}++;
				if ($options{FILTER} ne 'all' and $options{FILTER} ne 'fixed') { next; }

			} else {
				$result = "compliant";
				$stats{compliant}++;
				if ($options{FILTER} ne 'all' and $options{FILTER} ne 'compliant') { next; }

			}
			if ($display == HUMAN) {
				$~ = HOST_RESOURCE;
				$description = $resource[1] . " " . $resource[2];
				write;
			}

			if ($options{DISPLAY} eq 'full') {
				$st_a->execute($resource_id);
				while (@action = $st_a->fetchrow_array()) {
					if ($display == HUMAN) {
						$~ = HOST_ACTION;
						$description = $action[0];
						$result = $ACTION_RESULT{$action[1]};
						write;
					}
				}
			}
		}

		if ($display == HUMAN) {
			$~ = HOST_JOB_SUMMARY;
			$job_summary = job_summary_line(\%stats);
			write;
		}
	}
}

dispatch;

# FORMATS

format LAST_SEEN_TOP =
Hostname                             Last Seen At
--------                             ------------
.

format LAST_SEEN =
@<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<  @<<<<<<<<<<<<<<<<<
$hostname,                           $last_seen_at
.

format HOST_JOB =

@<<<<<<<<<<<<<<<<<<<<<<<<<<<<                   @####.#### s
$started_at,                                    $duration
------------------------------------------------------------
.

format HOST_RESOURCE =
  @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<   @>>>>>>>>>>>>
  $description,                                $result
.

format HOST_ACTION =
      @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<   @>>>>>>>>>>>>
    - $description,                            $result
.

format HOST_JOB_SUMMARY =
------------------------------------------------------------
@<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
$job_summary
.

format HOST_SUMMARY_TOP =
Hostname                           Compliance Summary
--------                           ------------------
.

format HOST_SUMMARY =
@<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<   @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
$host_name,                        $summary
.
