#include stdlib
fn ok
  print "ok %[o]u - %[p]s\n"
  bail 0
fn notok
  print "not ok %[o]u - %[p]s\n"
  bail 1

fn setup
  loglevel emergency %e
  exec "rm -rf t/tmp; mkdir -p t/tmp" %e
  umask 0 %e

fn setup.authdb
  call setup
  try util.authdb.close
  pragma authdb.root "t/tmp"
  umask 022 %e

  fs.put "t/tmp/passwd" <<EOF
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
jhacker:x:566:401:J. Random Hacker:/home/jhacker:/bin/zsh
oldman:NOTSET:1001:501:Old Man:/home/oldman:/bin/bash
EOF
  fs.put "t/tmp/shadow" <<EOF
root:HASH:15390:0:99999:7:::
daemon:*:15259:0:99999:7:::
jhacker:$$crypto:15200:0:99999:7:::
oldman:$$crypto:15200:0:99999:7:::
EOF
 fs.put "t/tmp/group" <<EOF
root:x:0:
daemon:x:1:abbadon
people:x:400:
rnd:x:401:
oldman:NOTSET:501:
EOF
  fs.put "t/tmp/gshadow" <<EOF
root:*::
daemon:*:abbadon:mephisto
people:*::
rnd:*::
oldman:$$gcrypt::
EOF

fn setup.hosts
  call setup
  umask 022 %e
  fs.mkdir "t/tmp/etc"
  fs.put "t/tmp/etc/hosts" <<EOF
127.0.0.1 localhost localhost.localdomain
8.8.7.6 host.example.com
8.8.6.4 host.fqdn.example.com with aliases
EOF
  pragma augeas.root "t/tmp"
  pragma augeas.libs "augeas/lenses"
  augeas.done
  augeas.init
  jnz +1 retv 0
    set %p "augeas.init failed!!!"
    call notok

fn setup.localsys
  call setup
  umask 022 %e
  fs.put "t/tmp/localsys" <<EOF
#!/bin/bash
echo -n "default setup.localsys version" >t/tmp/failed
exit 77
EOF
  fs.chmod "t/tmp/localsys" 0755
  pragma localsys.cmd "./t/tmp/localsys"

fn localsys-check
  fs.file? "t/tmp/failed" jnz +3
    fs.get "t/tmp/failed" %e
    string "%[p]s: localsys failed (%[e]s)" %p
    call notok

  fs.file? "t/tmp/ok" jz +2
    string "%[p]s: localsys never created the 'ok' file" %p
    call notok
  call ok

fn test.authdb.1
  call setup.authdb
  set %p "util.authdb.* - readonly mode"

  call util.authdb.open
  user.find "daemon"
  jz +2 call notok

  call util.authdb.close
  call ok

fn test.authdb.2
  call setup.authdb
  set %p "util.authdb.* - abandon changes"
  call util.authdb.open
  user.find "daemon"
  jz +2
    string "%[p]s: daemon user not found" %p
    call notok

  user.delete
  user.find "daemon"
  jnz +2
    string "%[p]s: daemon user not removed (in-memory)" %p
    call notok

  call util.authdb.close
  call util.authdb.open
  user.find "daemon"
  jz +2
    string "%[p]s: changes were not abandoned" %p
    call notok
  call ok

fn test.authdb.3
  call setup.authdb
  set %p "util.authdb.* - write changes"

  call util.authdb.open
  user.find "daemon"
  jz +2
    string "%[p]s: daemon user not found" %p
    call notok

  user.delete
  user.find "daemon"
  jnz +2
    string "%[p]s: daemon user not removed" %p
    call notok

  call util.authdb.save
  call util.authdb.close
  call util.authdb.open
  user.find "daemon"
  jnz +2
    string "%[p]s: util.authdb.save just ... didn't" %p
    call notok
  call ok

fn test.authdb.4
  call setup.authdb
  set %p "util.authdb.* - fail to open"

  pragma authdb.root "/path/to/nowhere"
  try util.authdb.open
  user.find "daemon"
  jnz +2
    string "%[p]s: daemon user found" %p
    call notok
  call ok

fn test.authdb.5
  call setup.authdb
  set %p "util.authdb.* handles write failures"

  call util.authdb.open
  exec "rm -rf t/tmp" %e ;; blow away t/tmp
  fs.stat "t/tmp" jnz +2
    string "%[p]s: failed to remove %[a]s" %p
    call notok

  try util.authdb.save    jnz +2
    string "%[p]s: util.authdb.save didn't bail out" %p
    call notok

  try util.authdb.close   jz +2
    string "%[p]s: util.authdb.close bailed" %p
    call notok
  call ok

fn test.copytree.1
  call setup
  set %p "util.copytree works"
  set %a "t/tmp/src"
  set %b "t/tmp/dst"
  fs.mkdir %a
  fs.mkdir %b

  string "%[a]s/file1" %c fs.put %c "{file1 contents}" fs.chmod %c 0640
  string "%[a]s/file2" %c fs.put %c "{file2 contents}" fs.chmod %c 0644
  string "%[a]s/file3" %c fs.put %c "{file3 contents}" fs.chmod %c 0755

  string "%[a]s/three"   %d fs.symlink %c %d
  string "%[a]s/symlink" %d fs.symlink "dangling" %d

  string "%[a]s/dir1" %c fs.mkdir %c fs.chmod %c 0700
  string "%[a]s/dir2" %c fs.mkdir %c fs.chmod %c 0755
  string "%[a]s/dir1/a" %c fs.mkdir %c fs.chmod %c 0755
  string "%[a]s/dir1/a/b" %c fs.mkdir %c fs.chmod %c 0755
  string "%[a]s/dir1/a/b/c" %c fs.mkdir %c fs.chmod %c 0755
  string "%[a]s/dir1/a/b/c/D" %c fs.put %c "{D contents}" fs.chmod %c 0604

  try util.copytree

  set %c "file1" string "%[b]s/%[c]s" %d
  fs.file? %d jz +2
    string "%[p]s: failed to copy %[c]s from %[a]s to %[b]s" %p
    call notok
  fs.mode %d %e
  eq %e 0640 jz +2
    string "%[p]s: failed to set mode of %[d]s based on src" %p
    call notok
  fs.get %d %e
  streq %e "{file1 contents}" jz +2
    string "%[p]s: %[d]s contents don't match src file" %p
    call notok

  set %c "file2" string "%[b]s/%[c]s" %d
  fs.file? %d jz +2
    string "%[p]s: failed to copy %[c]s from %[a]s to %[b]s" %p
    call notok
  fs.mode %d %e
  eq %e 0644 jz +2
    string "%[p]s: failed to set mode of %[d]s based on src" %p
    call notok
  fs.get %d %e
  streq %e "{file2 contents}" jz +2
    string "%[p]s: %[d]s contents don't match src file" %p
    call notok

  set %c "file3" string "%[b]s/%[c]s" %d
  fs.file? %d jz +2
    string "%[p]s: failed to copy %[c]s from %[a]s to %[b]s" %p
    call notok
  fs.mode %d %e
  eq %e 0755 jz +2
    string "%[p]s: failed to set mode of %[d]s based on src" %p
    call notok
  fs.get %d %e
  streq %e "{file3 contents}" jz +2
    string "%[p]s: %[d]s contents don't match src file" %p
    call notok

  set %c "three" string "%[b]s/%[c]s" %d 
  string "%[a]s/file3" %e ;; absolute symlinks are copied as-is...
  fs.symlink? %d jz +2
    string "%[p]s: failed to create symlink '%[c]s' at %[d]s" %p
    call notok
  fs.readlink %d %f
  streq %e %f jz +2
    string "%[p]s: symlink %[d]s created with bad target ('%[f]s', not '%[e]s')" %p
    call notok

  set %c "symlink" string "%[b]s/%[c]s" %d 
  set %e "dangling" ;; relative symlinks are copied as-is...
  fs.symlink? %d jz +2
    string "%[p]s: failed to create symlink '%[c]s' at %[d]s" %p
    call notok
  fs.readlink %d %f
  streq %e %f jz +2
    string "%[p]s: symlink %[d]s created with bad target ('%[f]s', not '%[e]s')" %p
    call notok

  set %c "dir1" string "%[b]s/%[c]s" %d
  fs.dir? %d jz +2
    string "%[p]s: failed to copy %[c]s from %[a]s to %[b]s" %p
    call notok
  fs.mode %d %e
  eq %e 0700 jz +2
    string "%[p]s: failed to set mode of %[d]s based on src" %p
    call notok

  set %c "dir1/a" string "%[b]s/%[c]s" %d
  fs.dir? %d jz +2
    string "%[p]s: failed to copy %[c]s from %[a]s to %[b]s" %p
    call notok
  fs.mode %d %e
  eq %e 0755 jz +2
    string "%[p]s: failed to set mode of %[d]s based on src" %p
    call notok

  set %c "dir1/a/b" string "%[b]s/%[c]s" %d
  fs.dir? %d jz +2
    string "%[p]s: failed to copy %[c]s from %[a]s to %[b]s" %p
    call notok
  fs.mode %d %e
  eq %e 0755 jz +2
    string "%[p]s: failed to set mode of %[d]s based on src" %p
    call notok

  set %c "dir1/a/b/c" string "%[b]s/%[c]s" %d
  fs.dir? %d jz +2
    string "%[p]s: failed to copy %[c]s from %[a]s to %[b]s" %p
    call notok
  fs.mode %d %e
  eq %e 0755 jz +2
    string "%[p]s: failed to set mode of %[d]s based on src" %p
    call notok

  set %c "dir1/a/b/c/D" string "%[b]s/%[c]s" %d
  fs.file? %d jz +2
    string "%[p]s: failed to copy %[c]s from %[a]s to %[b]s" %p
    call notok
  fs.mode %d %e
  eq %e 0604 jz +2
    string "%[p]s: failed to set mode of %[d]s based on src" %p
    call notok
  fs.get %d %e
  streq %e "{D contents}" jz +2
    string "%[p]s: %[d]s contents don't match src file" %p
    call notok

  call ok

fn test.copytree.2
  call setup
  set %p "util.copytree handles missing source"
  set %a "t/tmp/src"
  set %b "t/tmp/dst"
  fs.mkdir %b

  try util.copytree
  call ok

fn test.res.file.absent.1
  call setup
  set %p "res.file.absent deals with non-existent files"
  set %a "t/tmp/enoent"

  fs.stat %a jnz +2
    string "%[p]s: %[a]s already exists" %p
    call notok

  unflag "changed"
  try res.file.absent
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok
  fs.stat %a         jnz +2
    string "%[p]s: %[a]s was accidentally created" %p
    call notok
  call ok

fn test.res.file.absent.2
  call setup
  set %p "res.file.absent removes regular files"
  set %a "t/tmp/file"

  fs.put %a "{contents}"
  fs.file? %a jz +2
    string "%[p]s: %[a]s does not already exist" %p
    call notok

  unflag "changed"
  try res.file.absent
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok

  fs.stat %a         jnz +2
    string "%[p]s: %[a]s not removed" %p
    call notok
  call ok

fn test.res.file.absent.3
  call setup
  set %p "res.file.absent won't remove directories"
  set %a "t/tmp/dir"

  fs.mkdir %a
  fs.dir? %a jz +2
    string "%[p]s: %[a]s does not already exist" %p
    call notok

  unflag "changed"
  try res.file.absent
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok

  fs.stat %a         jz +2
    string "%[p]s: %[a]s was removed" %p
    call notok

  fs.dir? %a         jz +2
    string "%[p]s: %[a]s is no longer a directory" %p
    call notok
  call ok

fn test.res.file.absent.4
  call setup
  set %p "res.file.absent removes symbolic links"
  set %a "t/tmp/symlink"

  fs.symlink "x" %a jz +1
  fs.symlink? %a jz +2
    string "%[p]s: %[a]s does not already exist" %p
    call notok

  unflag "changed"
  try res.file.absent
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok

  fs.stat %a         jnz +2
    string "%[p]s: %[a]s still exists" %p
    call notok
  call ok

fn test.res.file.present.1
  call setup
  set %p "res.file.present creates a new file"
  set %a "t/tmp/new"

  fs.stat %a jnz +2
    string "%[p]s: %[a]s already exists" %p
    call notok

  unflag "changed"
  set %a "t/tmp/new"
  try res.file.present
  flagged? "changed"  jz +2
    string "%[p]s: not flagged" %p
    call notok

  fs.stat %a          jz +2
    string "%[p]s: %[a]s not created" %p
    call notok

  fs.file? %a         jz +2
    string "%[p]s: %[a]s is not a regular file" %p
    call notok

  fs.mode %a %b
  eq %b 0666          jz +2
    string "%[p]s: %[a]s has incorrect mode (got %[b]04o, expected 0666)" %p
    call notok
  call ok

fn test.res.file.present.2
  call setup
  set %p "res.file.present ignores extant files"
  set %a "t/tmp/file"

  fs.put %a "{contents}"
  fs.chmod %a 0641
  fs.inode %a %b
  fs.file? %a jz +2
    string "%[p]s: %[a]s does not already exist" %p
    call notok

  unflag "changed"
  try res.file.present
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok

  fs.stat %a         jz +2
    string "%[p]s: %[a]s does not still exist" %p
    call notok

  fs.file? %a        jz +2
    string "%[p]s: %[a]s is no longer a regular file" %p
    call notok

  fs.mode %a %c
  eq %c 0641         jz +2
    string "%[p]s: %[a]s has incorrect mode (got %[a]04o, expected 0641)" %p
    call notok

  fs.inode %a %c
  eq %c %b           jz +2
    string "%[p]s: %[a]s inode changed from %[b]i to %[c]i" %p
    call notok
  call ok

fn test.res.file.present.3
  call setup
  set %p "res.file.present will not remove directories"
  set %a "t/tmp/dir"

  fs.mkdir %a
  fs.dir? %a jz +2
    string "%[p]s: %[a]s does not exist" %p
    call notok
  fs.chmod %a 0705
  fs.inode %a %b

  unflag "changed"
  try res.file.present
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok

  fs.dir? %a         jz +2
    string "%[p]s: %[a]s is not a directory" %p
    call notok

  fs.mode %a %c
  eq %c 0705         jz +2
    string "%[p]s: %[a]s has incorrect mode (got %[a]04o, expected 0705)" %p
    call notok

  fs.inode %a %c
  eq %c %b           jz +2
    string "%[p]s: %[a]s inode changed from %[b]i to %[c]i" %p
    call notok
  call ok

fn test.res.file.present.4
  call setup
  set %p "res.file.present will remove symbolic links"
  set %a "t/tmp/symlink"

  fs.symlink "x" %a
  fs.symlink? %a jz +2
    string "%[p]s: %[a]s does not exist" %p
    call notok

  unflag "changed"
  try res.file.present
  flagged? "changed" jz +2
    string "%[p]s: flagged" %p
    call notok

  fs.stat %a         jz +2
    string "%[p]s: %[a]s does not exist" %p
    call notok

  fs.file? %a        jz +2
    string "%[p]s: %[a]s is not a regular file" %p
    call notok
  call ok

fn test.res.dir.absent.1
  call setup
  set %p "res.dir.absent deals with non-existent directories"
  set %a "t/tmp/enoent"

  fs.stat %a jnz +2
    string "%[p]s: %[a]s already exists" %p
    call notok

  unflag "changed"
  try res.dir.absent
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok

  fs.stat %a         jnz +2
    string "%[p]s: %[a]s was created somehow" %p
    call notok
  call ok

fn test.res.dir.absent.2
  call setup
  set %p "res.dir.absent will remove direcotires"
  set %a "t/tmp/dir"

  fs.mkdir %a
  fs.dir? %a jz +2
    string "%[p]s: %[a]s does not already exist" %p
    call notok

  unflag "changed"
  try res.dir.absent
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok

  fs.stat %a         jnz +2
    string "%[p]s: %[a]s still exists" %p
    call notok
  call ok

fn test.res.dir.absent.3
  call setup
  set %p "res.dir.absent will not remove regular files"
  set %a "t/tmp/file"

  fs.put %a "{contents}"
  fs.file? %a jz +2
    string "%[p]s: %[a]s does not already exist" %p
    call notok

  unflag "changed"
  try res.dir.absent
  jnz +2
    string "%[p]s: res.dir.absent did not bail" %p
    call notok

  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok

  fs.stat %a         jz +2
    string "%[p]s: %[a]s was removed" %p
    call notok

  fs.file? %a        jz +2
    string "%[p]s: %[a]s is no longer a regular file" %p
    call notok
  call ok

fn test.res.dir.absent.4
  call setup
  set %p "res.dir.absent will remove symbolic links"
  set %a "t/tmp/symlink"

  fs.symlink "target" %a
  fs.symlink? %a jz +2
    string "%[p]s: %[a]s does not already exist" %p
    call notok

  unflag "changed"
  try res.dir.absent
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok

  fs.stat %a         jnz +2
    string "%[p]s: %[a]s not removed" %p
    call notok
  call ok

fn test.res.dir.present.1
  call setup
  set %p "res.dir.present will create a new directory"
  set %a "t/tmp/new"

  fs.stat %a jnz +2
    string "%[p]s: %[a]s already exists" %p
    call notok

  unflag "changed"
  try res.dir.present
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok

  fs.stat %a         jz +2
    string "%[p]s: %[a]s not created" %p
    call notok

  fs.dir? %a         jz +2
    string "%[p]s: %[a]s is not a directory" %p
    call notok

  fs.mode %a %b
  eq %b 0777         jz +2
    string "%[p]s: mode of %[a]s is wrong (got %[b]04o, expected 0777)" %p
    call notok
  call ok

fn test.res.dir.present.2
  call setup
  set %p "res.dir.present will skip extant directories"
  set %a "t/tmp/dir"

  fs.mkdir %a
  fs.dir? %a jz +2
    string "%[p]s: %[a]s does not already exist" %p
    call notok

  unflag "changed"
  fs.inode %a %c

  try res.dir.present
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok

  fs.stat %a         jz +2
    string "%[p]s: %[a]s does not exist" %p
    call notok

  fs.dir? %a         jz +2
    string "%[p]s: %[a]s is not a directory" %p
    call notok

  fs.inode %a %d
  eq %c %d           jz +2
    string "%[p]s: inode changed from %[c]u to %[d]u" %p
    call notok
  call ok

fn test.res.dir.present.3
  call setup
  set %p "res.dir.present won't remove files"
  set %a "t/tmp/file"

  fs.put %a "{contents}"
  fs.file? %a jz +2
    string "%[p]s: %[a]s does not already exist" %p
    call notok

  unflag "changed"
  try res.dir.present
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok

  fs.stat %a         jz +2
    string "%[p]s: %[a]s does not exist" %p
    call notok

  fs.file? %a        jz +2
    string "%[p]s: %[a]s is no longer a regular file" %p
    call notok
  call ok

fn test.res.dir.present.4
  call setup
  set %p "res.dir.present will remove symbolic links"
  set %a "t/tmp/symlink"

  fs.symlink "x" %a
  fs.symlink? %a jz +2
    string "%[p]s: %[a]s does not exist" %p
    call notok

  unflag "changed"
  try res.dir.present
  flagged? "changed" jz +2
    string "%[p]s: flagged" %p
     call notok

  fs.stat %a         jz +2
    string "%[p]s: %[a]s does not exist" %p
     call notok

  fs.dir? %a         jz +2
     string "%[p]s: %[a]s is not a directory" %p
     call notok
  call ok

fn test.res.file.chmod.1
  call setup
  set %p "res.file.chmod works on files"
  set %a "t/tmp/file"
  set %b 0641

  fs.put %a "{contents}"
  fs.mode %a %c
  eq %b %c jnz +2
    string "%[p]s: %[a]s is already mode %[b]04o" %b
    call notok

  unflag "changed"
  try res.file.chmod
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok

  fs.mode %a %c
  eq %b %c           jz +2
    string "%[p]s: mode was not changed from %[c]04o to %[b]04o" %p
    call notok
  call ok

fn test.res.file.chmod.2
  set %p "res.file.chmod ignores files that are already correct"
  set %a "t/tmp/file"
  set %b 0666

  fs.put %a "{contents}"
  fs.chmod %a %b
  fs.mode %a %c
  eq %b %c jz +2
    string "%[p]s: %[a]s is mode %[c]04o (not %[b]04o)" %p
    call notok

  unflag "changed"
  try res.file.chmod
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok

  fs.mode %a %c
  eq %b %c           jz +2
    string "%[p]s: invalid mode (got %[c]04o, expecting %[c]04o)" %p
    call notok
  call ok

fn test.res.symlink.absent.1
  call setup
  set %p "res.symlink.absent deals with absent symlinks"
  set %a "t/tmp/symlink"

  fs.stat %a
  jnz +2
    string "%[p]s: %[a]s already exists" %p
    call notok

  unflag "changed"
  try res.symlink.absent
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok

  fs.stat %a         jnz +2
    string "%[p]s: %[a]s exists now" %p
    call notok
  call ok

fn test.res.symlink.absent.2
  call setup
  set %p "res.symlink.absent will not remove files"
  set %a "t/tmp/file"

  fs.put %a "{contents}"
  fs.file? %a
  jz +2
    string "%[p]s: %[a]s does not already exist" %p
    call notok

  unflag "changed"
  try res.symlink.absent
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok

  fs.stat %a         jz +2
    string "%[p]s: %[a]s was removed" %p
    call notok

  fs.file? %a        jz +2
    string "%[p]s: %[a]s is no longer a regular file" %p
    call notok
  call ok

fn test.res.symlink.absent.3
  call setup
  set %p "res.symlink.absent will not remove directories"
  set %a "t/tmp/dir"

  fs.mkdir %a
  fs.dir? %a
  jz +2
    string "%[p]s: %[a]s does not already exist" %p
    call notok

  unflag "changed"
  try res.symlink.absent
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok

  fs.stat %a         jz +2
    string "%[p]s: %[a]s was removed" %p
    call notok

  fs.dir? %a         jz +2
    string "%[p]s: %[a]s is no longer a directory" %p
    call notok
  call ok

fn test.res.symlink.absent.4
  call setup
  set %p "res.symlink.absent will remove extant symbolic links"
  set %a "t/tmp/symlink"

  fs.symlink "x" %a
  fs.symlink? %a
  jz +2
    string "%[p]s: %[a]s does not already exist" %p
    call notok

  unflag "changed"
  try res.symlink.absent
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok

  fs.stat %a
  jnz +2
    string "%[p]s: %[a]s still exists" %p
    call notok
  call ok

fn test.res.symlink.present.1
  call setup
  set %p "res.symlink.present creates a symbolic link"

  set %a "t/tmp/symlink"
  set %b "my-target"

  fs.stat %a
  jnz +2
    string "%[p]s: %[a]s already exists" %p
    call notok

  unflag "changed"
  try res.symlink.present
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok

  fs.stat %a         jz +2
    string "%[p]s: %[a]s not created" %p
    call notok

  fs.symlink? %a     jz +2
    string "%[p]s: %[a]s is not a symbolic link" %p
    call notok

  fs.readlink %a %c  jz +2
    string "%[p]s: failed to readlinke on %[a]s" %p
    call notok

  streq %b %c        jz +2
    string "%[p]s: %[a]s created with bad target (got '%[c]s', expecting '%[b]s')" %p
    call notok
  call ok

fn test.res.symlink.present.2
  call setup
  set %p "res.symlink.present will fix incorrect symbolic links"

  set %a "t/tmp/symlink"
  set %b "correct"

  fs.symlink "INCORRECT" %a
  fs.symlink? %a jz +2
    string "%[p]s: %[a]s does not already exist" %p
    call notok

  fs.readlink %a %c
  streq %b %c jnz +2
    string "%[p]s: %[a]s is already correct (it should point at '%[b]s', not %[c]s')" %p
    call notok

  unflag "changed"
  try res.symlink.present
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok

  fs.stat %a         jz +2
    string "%[p]s: %[a]s was removed" %p
    call notok

  fs.symlink? %a     jz +2
    string "%[p]s: %[a]s is no longer a symbolic link" %p
    call notok

  fs.readlink %a %c
  streq %b %c        jz +2
    string "%[p]s: %[a]s points at '%[c]s', not '%[b]s'" %p
    call notok
  call ok

fn test.res.symlink.present.3
  call setup
  set %p "res.symlink.present will not remove files"

  set %a "t/tmp/file"

  fs.put %a "{contents}"
  fs.file? %a jz +2
    string "%[p]s: %[a]s does not already exist" %p
    call notok

  unflag "changed"
  try res.symlink.present
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok

  fs.stat %a         jz +2
    string "%[p]s: %[a]s was removed" %p
    call notok

  fs.file? %a        jz +2
    string "%[p]s: %[a]s is no longer a file" %p
    call notok
  call ok

fn test.res.symlink.present.4
  call setup
  set %p "res.symlink.present will not remove directories"

  set %a "t/tmp/file"

  fs.mkdir %a
  fs.dir? %a jz +2
    string "%[p]s: %[a]s does not already exist" %p
    call notok

  unflag "changed"
  try res.symlink.present
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok

  fs.stat %a         jz +2
    string "%[p]s: %[a]s was removed" %p
    call notok

  fs.dir? %a         jz +2
    string "%[p]s: %[a]s is no longer a directory" %p
    call notok
  call ok

fn test.res.user.absent.1
  call setup.authdb
  call util.authdb.open
  set %p "res.user.absent handles absent users"

  set %a "notauser"
  user.find %a jnz +2
    string "%[p]s: %[a]s exists" %p
    call notok

  unflag "changed"
  try res.user.absent
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok

  call util.authdb.open
  user.find %a jnz +2
    string "%[p]s: %[a]s was created" %p
    call notok
  call util.authdb.close
  call ok

fn test.res.user.absent.2
  call setup.authdb
  call util.authdb.open
  set %p "res.user.absent can remove a user"

  set %a "daemon"
  user.find %a jz +2
    string "%[p]s: %[a]s does not exist" %p
    call notok

  unflag "changed"
  try res.user.absent
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok

  user.find %a jnz +2
    string "%[p]s: %[a]s still exists" %p
    call notok

  call util.authdb.close
  call ok

fn test.res.user.present.1
  call setup.authdb
  call util.authdb.open
  set %p "res.user.present ignores extant users"

  set %a "oldman" ;; leave the oldman alone
  set %b 0xffffffff
  set %c 0xffffffff
  set %d ""
  set %e ""
  set %f ""
  user.find %a jz +2
    string "%[p]s: %[a]s does not already exist" %p
    call notok

  unflag "changed"
  try res.user.present
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok

  user.find %a jz +2
    string "%[p]s: %[a]s was removed" %p
    call notok

  user.get "uid" %m set %n 1001
  eq %m %n jz +2
    string "%[p]s: %[a]s UID changed from %[n]u to %[o]u" %p
    call notok

  user.get "gid" %m set %n 501
  eq %m %n jz +2
    string "%[p]s: %[a]s GID changed from %[n]u to %[o]u" %p
    call notok

  user.get "home" %m set %n "/home/oldman"
  streq %m %n jz +2
    string "%[p]s: %[a]s home directory changed from '%[n]s' to '%[o]s'" %p
    call notok

  user.get "shell" %m set %n "/bin/bash"
  streq %m %n jz +2
    string "%[p]s: %[a]s login shell changed from '%[n]s' to '%[o]s'" %p
    call notok

  user.get "password" %m set %n "NOTSET"
  streq %m %n jz +2
    string "%[p]s: %[a]s cleartext password changed from '%[n]s' to '%[o]s'" %p
    call notok

  user.get "pwhash" %m set %n "$$crypto"
  streq %m %n jz +2
    string "%[p]s: %[a]s encrypted password changed from '%[n]s' to '%[o]s'" %p
    call notok

  call util.authdb.close
  call ok

fn test.res.user.present.2
  call setup.authdb
  call util.authdb.open
  set %p "res.user.present will create a new user account"

  set %a "newuser"
  set %b 2001
  set %c 300
  set %d "/home/newuser"
  set %e "/bin/zsh"
  set %f "$$crypto"
  user.find %a jnz +2
    string "%[p]s: %[a]s already exists" %p
    call notok

  unflag "changed"
  try res.user.present
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok

  user.find %a jz +2
    string "%[p]s: %[a]s was not created" %p
    call notok

  user.get "uid" %m
  eq %m %b jz +2
    string "%[p]s: %[a]s UID set to %[m]u, not %[b]u" %p
    call notok

  user.get "gid" %m
  eq %m %c jz +2
    string "%[p]s: %[a]s GID set to %[m]u, not %[c]u" %p
    call notok

  user.get "home" %m
  streq %m %d jz +2
    string "%[p]s: %[a]s home directory set to '%[m]s', not '%[d]s'" %p
    call notok

  user.get "shell" %m
  streq %m %e jz +2
    string "%[p]s: %[a]s login shell set to '%[m]s', not '%[e]s'" %p
    call notok

  user.get "password" %m
  streq %m "x" jz +2
    string "%[p]s: %[a]s cleartext password set to '%[m]s', not 'x'" %p
    call notok

  user.get "pwhash" %m
  streq %m %f jz +2
    string "%[p]s: %[a]s encrypted password set to '%[m]s', not '%[f]s'" %p
    call notok


  call util.authdb.close
  call ok

fn test.res.user.present.3
  call setup.authdb
  call util.authdb.open
  set %p "res.user.present will auto-generate UIDs if asked nicely"

  set %a "newuser"
  set %b 65536 ;; auto-generate
  set %c 300
  set %d "/home/newuser"
  set %e "/bin/zsh"
  set %f "$$crypto"
  user.find %a jnz +2
    string "%[p]s: %[a]s already exists" %p
    call notok

  unflag "changed"
  try res.user.present
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok

  user.find %a jz +2
    string "%[p]s: %[a]s was not created" %p
    call notok

  user.get "uid" %m set %b 1000
  eq %m %b jz +2
    string "%[p]s: %[a]s UID set to %[m]u, not %[b]u" %p
    call notok

  user.get "gid" %m
  eq %m %c jz +2
    string "%[p]s: %[a]s GID set to %[m]u, not %[c]u" %p
    call notok

  user.get "home" %m
  streq %m %d jz +2
    string "%[p]s: %[a]s home directory set to '%[m]s', not '%[d]s'" %p
    call notok

  user.get "shell" %m
  streq %m %e jz +2
    string "%[p]s: %[a]s login shell set to '%[m]s', not '%[e]s'" %p
    call notok

  user.get "password" %m
  streq %m "x" jz +2
    string "%[p]s: %[a]s cleartext password set to '%[m]s', not 'x'" %p
    call notok

  user.get "pwhash" %m
  streq %m %f jz +2
    string "%[p]s: %[a]s encrypted password set to '%[m]s', not '%[f]s'" %p
    call notok


  call util.authdb.close
  call ok

fn test.res.group.absent.1
  call setup.authdb
  call util.authdb.open
  set %p "res.group.absent handles absent groups"

  set %a "nosuchgroup"
  group.find %a jnz +2
    string "%[p]s: %[a]s already exists" %p
    call notok

  unflag "changed"
  try res.group.absent
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok

  group.find %a jnz +2
    string "%[p]s: %[a]s was created" %p
    call notok
  call util.authdb.close
  call ok

fn test.res.group.absent.2
  call setup.authdb
  call util.authdb.open
  set %p "res.group.absent ignores extant groups"

  set %a "daemon"
  group.find %a jz +2
    string "%[p]s: %[a]s does not already exist" %p
    call notok

  unflag "changed"
  try res.group.absent
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok

  group.find %a jnz +2
    string "%[p]s: %[a]s was not removed" %p
    call notok
  call util.authdb.close
  call ok

fn test.res.group.present.1
  call setup.authdb
  call util.authdb.open
  set %p "res.group.present ignores extant groups"

  set %a "oldman"
  set %b 0xffffffff
  group.find %a jz +2
    string "%[p]s: %[a]s does not already exist" %p
    call notok

  unflag "changed"
  try res.group.present
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok

  group.find %a jz +2
    string "%[p]s: %[a]s was removed" %p
    call notok

  group.get "gid" %m set %n 501
  eq %m %n jz +2
    string "%[p]s: %[a]s GID changed from %[n]u to %[m]u" %p
    call notok

  call util.authdb.close
  call ok

fn test.res.group.present.2
  call setup.authdb
  call util.authdb.open
  set %p "res.group.present will create a new group account"

  set %a "newgroup"
  set %b 502
  group.find %a jnz +2
    string "%[p]s: %[a]s already exists" %p
    call notok

  unflag "changed"
  try res.group.present
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok

  group.find %a jz +2
    string "%[p]s: %[a]s not created" %p
    call notok

  group.get "gid" %m set %n 502
  eq %m %n jz +2
    string "%[p]s: %[a]s GID set to %[m]u, not %[n]u" %p
    call notok

  call util.authdb.close
  call ok

fn test.res.group.present.3
  call setup.authdb
  call util.authdb.open
  set %p "res.group.present will auto-generate GIDs if asked nicely"

  set %a "newgroup"
  set %b 65536
  group.find %a jnz +2
    string "%[p]s: %[a]s already exists" %p
    call notok

  unflag "changed"
  try res.group.present
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok

  group.find %a jz +2
    string "%[p]s: %[a]s not created" %p
    call notok

  group.get "gid" %m set %n 1000
  eq %m %n jz +2
    string "%[p]s: %[a]s GID set to %[m]u, not %[n]u" %p
    call notok

  call util.authdb.close
  call ok

fn test.res.group.passwd.1
  call setup.authdb
  call util.authdb.open
  set %p "res.group.passwd works"

  set %a "oldman"
  set %b "$$n3wp@55w0rD"
  group.find %a jz +2
    string "%[p]s: %[a]s does not already exist" %p
    call notok

  unflag "changed"
  try res.group.passwd
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok

  group.find %a jz +2
    string "%[p]s: %[a]s was removed" %p
    call notok

  group.get "password" %e
  streq %e "*" jz +2
    string "%[p]s: cleartext password is '%[e]s', not '*'" %p
    call notok

  group.get "pwhash" %e
  streq %e %b jz +2
    string "%[p]s: encrypted password if '%[e]s', not '%[b]s'" %p
    call notok
  call ok

fn test.res.group.passwd.2
  call setup.authdb
  call util.authdb.open
  set %p "res.group.passwd skips absent groups"

  set %a "not-a-group"
  set %b "$$shouldfail"
  group.find %a jnz +2
    string "%[p]s: %[a]s exists" %p
    call notok

  unflag "changed"
  try res.group.passwd
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok

  group.find %a jnz +2
    string "%[p]s: %[a]s was created" %p
    call notok
  call ok

fn test.res.service.enable.1
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
svc-boot-status *: ok 0
EOF

  set %p "res.service.enable ignores enabled services"
  set %a "some-service"

  unflag "changed"
  try res.service.enable
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok
  call localsys-check

fn test.res.service.enable.2
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
svc-boot-status *:    1 # not enabled
svc-enable *:      ok 0 # enable successfully!
EOF

  set %p "res.service.enable enables services"
  set %a "some-service"

  unflag "changed"
  try res.service.enable
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok
  call localsys-check

fn test.res.service.enable.3
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
svc-boot-status *:    1 # not enabled
svc-enable *:      ok 1 # fail to enable
EOF

  set %p "res.service.enable can fail to enable services"
  set %a "some-service"

  unflag "changed"
  try res.service.enable
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok
  call localsys-check

fn test.res.service.disable.1
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
svc-boot-status *: ok 1 # disabled
EOF

  set %p "res.service.disable ignores disabled services"
  set %a "some-service"

  unflag "changed"
  try res.service.disable
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok
  call localsys-check

fn test.res.service.disable.2
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
svc-boot-status *:    0 # enabled
svc-disable *:     ok 0 # disabled successfully
EOF

  set %p "res.service.disable disables services"
  set %a "some-service"

  unflag "changed"
  try res.service.disable
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok
  call localsys-check

fn test.res.service.disable.3
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
svc-boot-status *:    0 # enabled
svc-disable *:     ok 1 # fail to disable
EOF

  set %p "res.service.disable can fail to disable services"
  set %a "some-service"

  unflag "changed"
  try res.service.disable
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok
  call localsys-check

fn test.res.service.start.1
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
svc-run-status *: ok 0 # already running
EOF

  set %p "res.service.start ignores running services"
  set %a "some-service"

  unflag "changed"
  try res.service.start
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok
  call localsys-check

fn test.res.service.start.2
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
svc-run-status *:    1 # stopped
svc-init * start: ok 0 # started successfully
EOF

  set %p "res.service.start starts stopped services"
  set %a "some-service"

  unflag "changed"
  try res.service.start
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok
  call localsys-check

fn test.res.service.start.3
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
svc-run-status *:    1 # stopped
svc-init * start: ok 1 # fail to start
EOF

  set %p "res.service.start can fail to start services"
  set %a "some-service"

  unflag "changed"
  try res.service.start
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok
  call localsys-check

fn test.res.service.stop.1
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
svc-run-status *: ok 1 # already stopped
EOF

  set %p "res.service.stop ignores stopped services"
  set %a "some-service"

  unflag "changed"
  try res.service.stop
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok
  call localsys-check

fn test.res.service.stop.2
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
svc-run-status *:    0 # running
svc-init * stop:  ok 0
EOF

  set %p "res.service.stop stops running services"
  set %a "some-service"

  unflag "changed"
  try res.service.stop
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok
  call localsys-check

fn test.res.service.stop.3
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
svc-run-status *:   0 # running
svc-init * stop: ok 1
EOF

  set %p "res.service.stop can fail to stop services"
  set %a "some-service"

  unflag "changed"
  try res.service.stop
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok
  call localsys-check

fn test.res.service.reload.1
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
svc-run-status *:     0 # running
svc-init * reload: ok 0
EOF

  set %p "res.service.reload can reload a running service"
  set %a "some-service"

  unflag "changed"
  try res.service.reload
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok
  call localsys-check

fn test.res.service.reload.2
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
svc-run-status *:     0 # running
svc-init * reload: ok 1 # fail to reload
EOF

  set %p "res.service.reload can fail reload a running service"
  set %a "some-service"

  unflag "changed"
  try res.service.reload
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok
  call localsys-check

fn test.res.service.reload.3
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
svc-run-status *:    1 # stopped
svc-init * start: ok 0 # started successfully
EOF

  set %p "res.service.reload will start a stopped service"
  set %a "some-service"

  unflag "changed"
  try res.service.reload
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok
  call localsys-check

fn test.res.service.reload.4
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
svc-run-status *:    1 # stopped
svc-init * start: ok 1 # fail to start
EOF

  set %p "res.service.reload can fail to start a stopped service"
  set %a "some-service"

  unflag "changed"
  try res.service.reload
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok
  call localsys-check

fn test.res.service.restart.1
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
svc-run-status *:     0 # running
svc-init * restart: ok 0
EOF

  set %p "res.service.restart can restart a running service"
  set %a "some-service"

  unflag "changed"
  try res.service.restart
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok
  call localsys-check

fn test.res.service.restart.2
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
svc-run-status *:     0 # running
svc-init * restart: ok 1 # fail to restart
EOF

  set %p "res.service.restart can fail restart a running service"
  set %a "some-service"

  unflag "changed"
  try res.service.restart
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok
  call localsys-check

fn test.res.service.restart.3
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
svc-run-status *:    1 # stopped
svc-init * start: ok 0 # started successfully
EOF

  set %p "res.service.restart will start a stopped service"
  set %a "some-service"

  unflag "changed"
  try res.service.restart
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok
  call localsys-check

fn test.res.service.restart.4
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
svc-run-status *:    1 # stopped
svc-init * start: ok 1 # fail to start
EOF

  set %p "res.service.restart can fail to start a stopped service"
  set %a "some-service"

  unflag "changed"
  try res.service.restart
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok
  call localsys-check

fn test.res.host.absent.1
  call setup.hosts
  set %p "res.host.absent will remove host records"
  set %a "8.8.7.6"
  set %b "host.example.com"

  string "/files/etc/hosts/*[ipaddr = \"%[a]s\" and canonical = \"%[b]s\"]" %e
  augeas.find %e %f jz +2
    string "%[p]s: hosts entry not already present" %p
    call notok

  unflag "changed"
  try res.host.absent
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok

  string "/files/etc/hosts/*[ipaddr = \"%[a]s\" and canonical = \"%[b]s\"]" %e
  augeas.find %e %f jnz +2
    string "%[p]s: hosts entry still present" %p
    call notok
  call ok

fn test.res.host.absent.2
  call setup.hosts
  set %p "res.host.absent skips non-existent host records"
  set %a "3.3.3.3"
  set %b "enoent.fq.dn"

  string "/files/etc/hosts/*[ipaddr = \"%[a]s\" and canonical = \"%[b]s\"]" %e
  augeas.find %e %f jnz +2
    string "%[p]s: hosts entry already present" %p
    call notok

  unflag "changed"
  try res.host.absent
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok

  string "/files/etc/hosts/*[ipaddr = \"%[a]s\" and canonical = \"%[b]s\"]" %e
  augeas.find %e %f jnz +2
    string "%[p]s: hosts entry was created" %p
    call notok
  call ok

fn test.res.host.absent.3
  call setup.hosts
  set %p "res.host.absent must match both IP and FQDN"
  set %a "8.8.7.6"
  set %b "enoent.fq.dn"

  unflag "changed"
  try res.host.absent
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok

  string "/files/etc/hosts/*[ipaddr = \"%[a]s\"]" %e
  augeas.find %e %f jz +2
    string "%[p]s: ip %[a]s entry was removed" %p
    call notok

  set %a "172.16.30.188"
  set %b "host.example.com"

  unflag "changed"
  try res.host.absent
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok

  string "/files/etc/hosts/*[canonical = \"%[b]s\"]" %e
  augeas.find %e %f jz +2
    string "%[p]s: fqdn %[b]s entry was removed" %p
    call notok
  call ok

fn test.res.host.present.1
  call setup.hosts
  set %p "res.host.present skips pre-existing host entries"
  set %a "8.8.7.6"
  set %b "host.example.com"

  unflag "changed"
  try res.host.present
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok

  string "/files/etc/hosts/*[ipaddr = \"%[a]s\" and canonical = \"%[b]s\"]" %e
  augeas.find %e %f jz +2
    string "%[p]s: hosts entry was removed" %p
    call notok
  call ok

fn test.res.host.present.2
  call setup.hosts
  set %p "res.host.present creates new, barebones entries"
  set %a "10.86.86.86"
  set %b "new.host.example.com"

  unflag "changed"
  try res.host.present
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok

  string "/files/etc/hosts/*[ipaddr = \"%[a]s\" and canonical = \"%[b]s\"]" %e
  augeas.find %e %f jz +2
    string "%[p]s: host entry not created" %p
    call notok
  call ok

fn test.res.host.present.3
  call setup.hosts
  set %p "res.host.present can create overlapping entries"
  set %a "10.10.10.10"
  set %b "host.example.com"

  unflag "changed"
  try res.host.present
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok

  string "/files/etc/hosts/*[ipaddr = \"%[a]s\" and canonical = \"%[b]s\"]" %e
  augeas.find %e %f jz +2
    string "%[p]s: host entry not created" %p
    call notok

  string "/files/etc/hosts/*[ipaddr = \"8.8.7.6\" and canonical = \"%[b]s\"]" %e
  augeas.find %e %f jz +2
    string "%[p]s: existing host entry was removed / overwritten" %p
    call notok
  call ok

fn test.res.host.aliases.1
  call setup.hosts
  set %p "res.host.clear-aliases ignores non-existent hosts"
  set %a "1.1.1.1"
  set %b "enoent.fq.dn"

  unflag "changed"
  try res.host.clear-aliases
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok

  string "/files/etc/hosts/*[ipaddr = \"%[a]s\" and canonical = \"%[b]s\"]" %e
  augeas.find %e %f jnz +2
    string "%[p]s: entry was created" %p
    call notok
  call ok

fn test.res.host.aliases.2
  call setup.hosts
  set %p "res.host.clear-aliases removes all alias records"
  set %a "8.8.6.4"
  set %b "host.fqdn.example.com"

  string "/files/etc/hosts/*[alias = \"with\"]" %e
  augeas.find %e %f jz +2
    string "%[p]s: alias 'with' not found" %p
    call notok

  unflag "changed"
  try res.host.clear-aliases
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok

  string "/files/etc/hosts/*[alias = \"with\"]" %e
  augeas.find %e %f jnz +2
    string "%[p]s: alias 'with' still exists" %p
    call notok
  call ok

fn test.res.host.aliases.3
  call setup.hosts
  set %p "res.host.add-alias ignores non-existent hosts"
  set %a "1.1.1.1"
  set %b "enoent.tld"

  unflag "changed"
  try res.host.add-alias
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok
  call ok

fn test.res.host.aliases.4
  call setup.hosts
  set %p "res.host.add-alias adds a host alias"
  set %a "8.8.7.6"
  set %b "host.example.com"
  set %c 0 ;; index
  set %d "alias1"

  string "/files/etc/hosts/*[alias = \"alias1\"]" %e
  augeas.find %e %f jnz +2
    string "%[p]s: alias 'alias1' already exists" %p
    call notok

  unflag "changed"
  try res.host.add-alias
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok
  augeas.write jz +3
    augeas.perror "write failed"
    string "%[p]s: failed to write augeas changes" %p
    call notok

  string "/files/etc/hosts/*[alias = \"alias1\"]" %e
  augeas.find %e %f jz +2
    string "%[p]s: alias 'alias1' not created" %p
    call notok
  call ok

fn test.res.package.absent.1
  call setup.localsys
  set %p "res.package.absent handles uninstalled packages"
  set %a "a-package"

  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
pkg-version *: ok 1
EOF

  unflag "changed"
  try res.package.absent
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok
  call localsys-check

fn test.res.package.absent.2
  call setup.localsys
  set %p "res.package.absent will uninstall packages"
  set %a "a-package"

  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
pkg-version *:    0 : 1.2.3-16 # installed
pkg-remove *:  ok 0            # removed
EOF

  unflag "changed"
  try res.package.absent
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok
  call localsys-check

fn test.res.package.absent.3
  call setup.localsys
  set %p "res.package.absent can fail to uninstall packages"
  set %a "a-package"

  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
pkg-version *:    0 : 1.2.3-16 # installed
pkg-remove *:  ok 1            # failed to remove
EOF

  unflag "changed"
  try res.package.absent
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok
  call localsys-check

fn test.res.package.absent.4
  call setup.localsys
  set %p "res.package.absent can fail to uninstall packages"
  set %a "a-package"

  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
pkg-version *: ok 9 # fail to detect version
EOF

  unflag "changed"
  try res.package.absent
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok
  call localsys-check

fn test.res.package.install.1
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
pkg-version *: ok 0 : 1.2.3-16 # installed
EOF

  set %p "res.package.install skips already-installed packages"
  set %a "a-package"
  set %b ""

  unflag "changed"
  try res.package.install
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok
  call localsys-check

fn test.res.package.install.2
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
pkg-version *: ok 42 # fail
EOF

  set %p "res.package.install can install a new package"
  set %a "a-package"
  set %b ""

  unflag "changed"
  try res.package.install
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok
  call localsys-check

fn test.res.package.install.3
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
pkg-version *:           1 # not installed
pkg-install * latest: ok 0 # installed ok
EOF

  set %p "res.package.install can install a new package"
  set %a "a-package"
  set %b ""

  unflag "changed"
  try res.package.install
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok
  call localsys-check

fn test.res.package.install.4
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
pkg-version *:           1 # not installed
pkg-install * latest: ok 1 # install failed
EOF

  set %p "res.package.install can fail to install a new package"
  set %a "a-package"
  set %b ""

  unflag "changed"
  try res.package.install
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok
  call localsys-check

fn test.res.package.install.5
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
pkg-version *:          1 # not installed
pkg-install * 1.2.3: ok 0 # installed
EOF

  set %p "res.package.install can install a specific version"
  set %a "a-package"
  set %b "1.2.3"

  unflag "changed"
  try res.package.install
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok
  call localsys-check

fn test.res.package.install.6
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
pkg-version *:          1 # not installed
pkg-install * 1.2.3: ok 1 # install failed
EOF

  set %p "res.package.install can install a specific version"
  set %a "a-package"
  set %b "1.2.3"

  unflag "changed"
  try res.package.install
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok
  call localsys-check

fn test.res.package.install.7
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
pkg-version *:          0 : 0.3.4 # installed
pkg-install * 1.2.3: ok 0         # updated
EOF

  set %p "res.package.install can update to a specific version"
  set %a "a-package"
  set %b "1.2.3"

  unflag "changed"
  try res.package.install
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok
  call localsys-check

fn test.res.package.install.8
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
pkg-version *:          0 : 0.3.4    # installed
pkg-latest *:           0 : 1.2.3    # latest version
pkg-install * 1.2.3: ok 0            # updated
EOF

  set %p "res.package.install can update to the latest version"
  set %a "a-package"
  set %b "latest"

  unflag "changed"
  try res.package.install
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok
  call localsys-check

fn test.res.package.install.9
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
pkg-version *:          0 : 2.4.4    # installed
pkg-latest *:        ok 0 : 2.4.4    # latest version
EOF

  set %p "res.package.install skips packages at the latest version"
  set %a "a-package"
  set %b "latest"

  unflag "changed"
  try res.package.install
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok
  call localsys-check

fn test.res.package.install.10
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
pkg-version *:       ok 0 : 2.4.4    # installed
EOF

  set %p "res.package.install skips packages at the correct version"
  set %a "a-package"
  set %b "2.4.4"

  unflag "changed"
  try res.package.install
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok
  call localsys-check

fn test.res.package.install.11
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
pkg-version *:          0 : 1.0.1    # installed
pkg-latest *:        ok 0 : 1.2.2    # detect latest version
pkg-install * 1.2.2:    1            # fail to update
EOF

  set %p "res.package.install can fail to update to latest version"
  set %a "a-package"
  set %b "latest"

  unflag "changed"
  try res.package.install
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok
  call localsys-check

fn test.res.package.install.12
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
pkg-version *:          0 : 1.0.1    # installed
pkg-install * 1.2.2: ok 1            # fail to update
EOF

  set %p "res.package.install can fail to update to a specific version"
  set %a "a-package"
  set %b "1.2.2"

  unflag "changed"
  try res.package.install
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok
  call localsys-check

fn test.res.package.install.13
  call setup.localsys
  fs.put "t/tmp/localsys" <<EOF
#!./t/patterns
pkg-version *:    0 : 1.0.1    # installed
pkg-latest *:  ok 1            # fail to detect latest
EOF

  set %p "res.package.install can fail to update to a specific version"
  set %a "a-package"
  set %b "latest"

  unflag "changed"
  try res.package.install
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok
  call localsys-check

fn test.res.chgrp.1
  call setup.authdb
  set %p "fs.chgrp ignores absent files"
  set %a "t/tmp/enoent"
  set %b "people"

  fs.stat %a jnz +2
    string "%[p]s: %[a]s already exists" %p
    call notok

  unflag "changed"
  try res.file.chgrp
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok

  fs.stat %a jnz +2
    string "%[p]s: %[a]s was created" %p
    call notok
  call ok

fn test.res.chgrp.2
  call setup.authdb
  set %p "fs.chgrp skips files that are properly chgrp'd"
  set %a "t/tmp/file"
  set %b "people" set %c 400

  fs.put   %a "{contents}"
  fs.chgrp %a %c
  fs.stat %a jz +2
    string "%[p]s: %[a]s does not already exist" %p
    call notok

  unflag "changed"
  try res.file.chgrp
  jz +2
    string "%[p]s: did not return 0 (indicated other failure)" %p
    call notok
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok

  fs.file? %a jz +2
    string "%[p]s: %[a]s was removed" %p
    call notok
  fs.gid %a %d eq %c %d jz +2
    string "%[p]s: %[a]s is group-owned by %[d]u, not %[c]u (%[b]s)" %p
    call notok
  call ok

fn test.res.chgrp.3
  call setup.authdb
  set %p "fs.chgrp handles failed group lookup"
  set %a "t/tmp/file"
  set %b "ENOENT"

  fs.put  %a "{contents}"
  fs.stat %a jz +2
    string "%[p]s: %[a]s does not already exist" %p
    call notok

  unflag "changed"
  try res.file.chgrp
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok

  fs.file? %a jz +2
    string "%[p]s: %[a]s was removed" %p
    call notok
  call ok

fn test.res.chgrp.4
  call setup.authdb
  set %p "fs.chgrp changes group-ownership"
  set %a "t/tmp/file"
  set %b "people" set %c 400

  fs.put   %a "{contents}"
  fs.chgrp %a 401 ;; 'rnd' group
  fs.stat %a jz +2
    string "%[p]s: %[a]s does not already exist" %p
    call notok

  unflag "changed"
  try res.file.chgrp
  jz +2
    string "%[p]s: did not return 0 (indicated other failure)" %p
    call notok
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok

  fs.file? %a jz +2
    string "%[p]s: %[a]s was removed" %p
    call notok
  fs.gid %a %d eq %c %d jz +2
    string "%[p]s: %[a]s is group-owned by %[d]u, not %[c]u (%[b]s)" %p
    call notok
  call ok

fn test.res.chown.1
  call setup.authdb
  set %p "fs.chown ignores absent files"
  set %a "t/tmp/enoent"
  set %b "jhacker"

  fs.stat %a jnz +2
    string "%[p]s: %[a]s already exists" %p
    call notok

  unflag "changed"
  try res.file.chown
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok

  fs.stat %a jnz +2
    string "%[p]s: %[a]s was created" %p
    call notok
  call ok

fn test.res.chown.2
  call setup.authdb
  set %p "fs.chown skips files that are properly chown'd"
  set %a "t/tmp/file"
  set %b "jhacker" set %c 566

  fs.put   %a "{contents}"
  fs.chown %a %c
  fs.stat %a jz +2
    string "%[p]s: %[a]s does not already exist" %p
    call notok

  unflag "changed"
  try res.file.chown
  jz +2
    string "%[p]s: did not return 0 (indicated other failure)" %p
    call notok
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok

  fs.file? %a jz +2
    string "%[p]s: %[a]s was removed" %p
    call notok
  fs.uid %a %d eq %c %d jz +2
    string "%[p]s: %[a]s is owned by %[d]u, not %[c]u (%[b]s)" %p
    call notok
  call ok

fn test.res.chown.3
  call setup.authdb
  set %p "fs.chown handles failed user lookup"
  set %a "t/tmp/file"
  set %b "ENOENT"

  fs.put  %a "{contents}"
  fs.stat %a jz +2
    string "%[p]s: %[a]s does not already exist" %p
    call notok

  unflag "changed"
  try res.file.chown
  flagged? "changed" jnz +2
    string "%[p]s: flagged" %p
    call notok

  fs.file? %a jz +2
    string "%[p]s: %[a]s was removed" %p
    call notok
  call ok

fn test.res.chown.4
  call setup.authdb
  set %p "fs.chown changes ownership"
  set %a "t/tmp/file"
  set %b "jhacker" set %c 566

  fs.put   %a "{contents}"
  fs.chown %a 0 ;; root
  fs.stat %a jz +2
    string "%[p]s: %[a]s does not already exist" %p
    call notok

  unflag "changed"
  try res.file.chown
  jz +2
    string "%[p]s: did not return 0 (indicated other failure)" %p
    call notok
  flagged? "changed" jz +2
    string "%[p]s: not flagged" %p
    call notok

  fs.file? %a jz +2
    string "%[p]s: %[a]s was removed" %p
    call notok
  fs.uid %a %d eq %c %d jz +2
    string "%[p]s: %[a]s is owned by %[d]u, not %[c]u (%[b]s)" %p
    call notok
  call ok

fn test.res.run-as.1
  call setup
  set %p "util.run* function sets user/group to run as"
  string "%[c]u:%[c]u/%[d]u:%[d]u" %n

            call util.runuser
  set %a %b call util.rungroup

  exec "perl -MPOSIX -e 'print geteuid.\":\".getuid.\"/\".getegid.\":\".getgid'" %m
  jz +3
    acc %e
    string "perl id verification process exited non-zero (rc=%[e]u)" %p
    call notok
  streq %m %n jz +2
    string "%[p]s: got '%[m]s'; expected '%[n]s'" %p
    call notok
  call ok

fn test.res.run-as.2
  call setup
  set %p "util.run* can handle invalid users / group"
  set %a "xyzzy bad user"  try util.runuser
  set %a "xyzzy bad group" try util.rungroup
  call ok

fn test.res.user.mkhome.1
  call setup
  set %p "res.user.mkhome skips home directories that exist"
  set %a "t/tmp/home"
  set %b "" ; no skel dir
  set %c 800
  set %d 900

  fs.mkdir %a
  fs.chown %a 1
  fs.chgrp %a 2
  fs.dir? %a jz +2
    string "%[p]s: %[a]s does not already exist" %p
    call notok

  try res.user.mkhome
  jz +2
    string "%[p]s: res.user.mkhome returned non-zero" %p
    call notok

  fs.dir? %a jz +2
    string "%[p]s: %[a]s was removed" %p
    call notok

  fs.uid %a %e eq %e 1 jz +2
    string "%[p]s: %[a]s was chowned to %[e]u (not 1)" %p
    call notok
  fs.gid %a %e eq %e 2 jz +2
    string "%[p]s: %[a]s was chgrped to %[e]u (not 2)" %p
    call notok
  call ok

fn test.res.user.mkhome.2
  call setup
  set %p "res.user.mkhome will create home directories"
  set %a "t/tmp/home"
  set %b "" ; no skel dir
  set %c 800
  set %d 900

  fs.dir? %a jnz +2
    string "%[p]s: %[a]s already exists" %p
    call notok

  try res.user.mkhome
  jz +2
    string "%[p]s: res.user.mkhome returned non-zero" %p
    call notok

  fs.dir? %a jz +2
    string "%[p]s: %[a]s was not created" %p
    call notok

  fs.uid %a %e eq %e %c jz +2
    string "%[p]s: %[a]s was chowned to %[e]u (not %[c]u)" %p
    call notok
  fs.gid %a %e eq %e %d jz +2
    string "%[p]s: %[a]s was chgrped to %[e]u (not %[d]u)" %p
    call notok
  call ok

fn test.res.user.mkhome.3
  call setup
  set %p "res.user.mkhome will remove symbolic links"
  set %a "t/tmp/home"
  set %b "" ; no skel dir
  set %c 800
  set %d 900

  fs.symlink "x" %a
  fs.symlink? %a jz +2
    string "%[p]s: %[a]s does not already exist" %p
    call notok

  try res.user.mkhome
  jz +2
    string "%[p]s: res.user.mkhome returned non-zero" %p
    call notok

  fs.dir? %a jz +2
    string "%[p]s: %[a]s was not created" %p
    call notok

  fs.uid %a %e eq %e %c jz +2
    string "%[p]s: %[a]s was chowned to %[e]u (not %[c]u)" %p
    call notok
  fs.gid %a %e eq %e %d jz +2
    string "%[p]s: %[a]s was chgrped to %[e]u (not %[d]u)" %p
    call notok
  call ok

fn test.res.user.mkhome.4
  call setup
  set %p "res.user.mkhome will not remove files"
  set %a "t/tmp/home"
  set %b "" ; no skel dir
  set %c 800
  set %d 900

  fs.put %a "{contents}"
  fs.file? %a jz +2
    string "%[p]s: %[a]s does not already exist" %p
    call notok

  try res.user.mkhome
  jnz +2
    string "%[p]s: res.user.mkhome returned zero" %p
    call notok

  fs.file? %a jz +2
    string "%[p]s: %[a]s was removed" %p
    call notok
  call ok

fn test.res.user.mkhome.5
  call setup
  umask 022 %p
  set %p "res.user.mkhome will copy the skel directory"
  set %a "t/tmp/home"
  set %b "t/tmp/skel"
  set %c 800
  set %d 900

  fs.mkdir "t/tmp/skel"
  fs.put   "t/tmp/skel/.bashrc" "#bashrc\n"
  fs.put   "t/tmp/skel/README"  "good job!\n"
  fs.mkdir "t/tmp/skel/.ssh"
  fs.chmod "t/tmp/skel/.ssh" 0700
  fs.put   "t/tmp/skel/.ssh/config" "#config\n"
  fs.chmod "t/tmp/skel/.ssh/config" 0600

  fs.dir? %a jnz +2
    string "%[p]s: %[a]s already exists" %p
    call notok

  try res.user.mkhome
  jz +2
    string "%[p]s: res.user.mkhome returned non-zero" %p
    call notok

  fs.dir? %a jz +2
    string "%[p]s: %[a]s was not created" %p
    call notok

  fs.uid %a %e eq %e %c jz +2
    string "%[p]s: %[a]s was chowned to %[e]u (not %[c]u)" %p
    call notok
  fs.gid %a %e eq %e %d jz +2
    string "%[p]s: %[a]s was chgrped to %[e]u (not %[d]u)" %p
    call notok

  fs.file? "t/tmp/home/README" jz +2
    string "%[p]s: did not copy README from skel dir" %p
    call notok
  fs.mode "t/tmp/home/README" %e
  eq %e 0644 jz +2
    string "%[p]s: README not chmodded 0644 (%[e]04o)" %p
    call notok
  fs.uid "t/tmp/home/README" %e
  eq %e 800 jz +2
    string "%[p]s: README not chowned to UID 800 (%[e]u)" %p
    call notok
  fs.gid "t/tmp/home/README" %e
  eq %e 900 jz +2
    string "%[p]s: README not chowned to GID 900 (%[e]u)" %p
    call notok
  fs.get "t/tmp/home/README" %e
  set %f "good job!\n" streq %e %f jz +2
    string "%[p]s: contents of README - got '%[e]s', expecting '%[f]s'" %p
    call notok

  fs.file? "t/tmp/home/.bashrc" jz +2
    string "%[p]s: did not copy .bashrc from skel dir" %p
    call notok
  fs.mode "t/tmp/home/.bashrc" %e
  eq %e 0644 jz +2
    string "%[p]s: .bashrc not chmodded 0644 (%[e]04o)" %p
    call notok
  fs.uid "t/tmp/home/.bashrc" %e
  eq %e 800 jz +2
    string "%[p]s: .bashrc not chowned to UID 800 (%[e]u)" %p
    call notok
  fs.gid "t/tmp/home/.bashrc" %e
  eq %e 900 jz +2
    string "%[p]s: .bashrc not chowned to GID 900 (%[e]u)" %p
    call notok
  fs.get "t/tmp/home/.bashrc" %e
  set %f "#bashrc\n" streq %e %f jz +2
    string "%[p]s: contents of .bashrc - got '%[e]s', expecting '%[f]s'" %p
    call notok

  fs.dir? "t/tmp/home/.ssh" jz +2
    string "%[p]s: did not copy .ssh/ from skel dir" %p
    call notok
  fs.mode "t/tmp/home/.ssh" %e
  eq %e 0700 jz +2
    string "%[p]s: .ssh not chmodded 0700 (%[e]04o)" %p
    call notok
  fs.uid "t/tmp/home/.ssh" %e
  eq %e 800 jz +2
    string "%[p]s: .ssh not chowned to UID 800 (%[e]u)" %p
    call notok
  fs.gid "t/tmp/home/.ssh" %e
  eq %e 900 jz +2
    string "%[p]s: .ssh not chowned to GID 900 (%[e]u)" %p
    call notok

  fs.file? "t/tmp/home/.ssh/config" jz +2
    string "%[p]s: did not copy .ssh/config from skel dir" %p
    call notok
  fs.mode "t/tmp/home/.ssh/config" %e
  eq %e 0600 jz +2
    string "%[p]s: .ssh/config not chmodded 0600 (%[e]04o)" %p
    call notok
  fs.uid "t/tmp/home/.ssh/config" %e
  eq %e 800 jz +2
    string "%[p]s: .ssh/config not chowned to UID 800 (%[e]u)" %p
    call notok
  fs.gid "t/tmp/home/.ssh/config" %e
  eq %e 900 jz +2
    string "%[p]s: .ssh/config not chowned to GID 900 (%[e]u)" %p
    call notok
  fs.get "t/tmp/home/.ssh/config" %e
  set %f "#config\n" streq %e %f jz +2
    string "%[p]s: contents of .ssh/config - got '%[e]s', expecting '%[f]s'" %p
    call notok
  call ok

fn main
  set %o 0
  set %p 0

  add %o 1 try test.authdb.1 jz +1 set %p 1
  add %o 1 try test.authdb.2 jz +1 set %p 1
  add %o 1 try test.authdb.3 jz +1 set %p 1
  add %o 1 try test.authdb.4 jz +1 set %p 1
  add %o 1 try test.authdb.5 jz +1 set %p 1

  add %o 1 try test.copytree.1 jz +1 set %p 1
  add %o 1 try test.copytree.2 jz +1 set %p 1

  add %o 1 try test.res.file.absent.1 jz +1 set %p 1
  add %o 1 try test.res.file.absent.2 jz +1 set %p 1
  add %o 1 try test.res.file.absent.3 jz +1 set %p 1
  add %o 1 try test.res.file.absent.4 jz +1 set %p 1

  add %o 1 try test.res.file.present.1 jz +1 set %p 1
  add %o 1 try test.res.file.present.2 jz +1 set %p 1
  add %o 1 try test.res.file.present.3 jz +1 set %p 1
  add %o 1 try test.res.file.present.4 jz +1 set %p 1

  add %o 1 try test.res.dir.absent.1 jz +1 set %p 1
  add %o 1 try test.res.dir.absent.2 jz +1 set %p 1
  add %o 1 try test.res.dir.absent.3 jz +1 set %p 1
  add %o 1 try test.res.dir.absent.4 jz +1 set %p 1

  add %o 1 try test.res.dir.present.1 jz +1 set %p 1
  add %o 1 try test.res.dir.present.2 jz +1 set %p 1
  add %o 1 try test.res.dir.present.3 jz +1 set %p 1
  add %o 1 try test.res.dir.present.4 jz +1 set %p 1

  add %o 1 try test.res.file.chmod.1 jz +1 set %p 1
  add %o 1 try test.res.file.chmod.2 jz +1 set %p 1

  ;; FIXME: I have no idea how we test res.file.contents
  ;; since it requires a 0mq context to retrieve files

  add %o 1 try test.res.symlink.absent.1 jz +1 set %p 1
  add %o 1 try test.res.symlink.absent.2 jz +1 set %p 1
  add %o 1 try test.res.symlink.absent.3 jz +1 set %p 1
  add %o 1 try test.res.symlink.absent.4 jz +1 set %p 1

  add %o 1 try test.res.symlink.present.1 jz +1 set %p 1
  add %o 1 try test.res.symlink.present.2 jz +1 set %p 1
  add %o 1 try test.res.symlink.present.3 jz +1 set %p 1
  add %o 1 try test.res.symlink.present.4 jz +1 set %p 1

  add %o 1 try test.res.user.absent.1 jz +1 set %p 1
  add %o 1 try test.res.user.absent.2 jz +1 set %p 1

  add %o 1 try test.res.user.present.1 jz +1 set %p 1
  add %o 1 try test.res.user.present.2 jz +1 set %p 1
  add %o 1 try test.res.user.present.3 jz +1 set %p 1

  add %o 1 try test.res.group.absent.1 jz +1 set %p 1
  add %o 1 try test.res.group.absent.2 jz +1 set %p 1

  add %o 1 try test.res.group.present.1 jz +1 set %p 1
  add %o 1 try test.res.group.present.2 jz +1 set %p 1
  add %o 1 try test.res.group.present.3 jz +1 set %p 1

  add %o 1 try test.res.group.passwd.1 jz +1 set %p 1
  add %o 1 try test.res.group.passwd.2 jz +1 set %p 1

  add %o 1 try test.res.service.enable.1 jz +1 set %p 1
  add %o 1 try test.res.service.enable.2 jz +1 set %p 1
  add %o 1 try test.res.service.enable.3 jz +1 set %p 1

  add %o 1 try test.res.service.disable.1 jz +1 set %p 1
  add %o 1 try test.res.service.disable.2 jz +1 set %p 1
  add %o 1 try test.res.service.disable.3 jz +1 set %p 1

  add %o 1 try test.res.service.start.1 jz +1 set %p 1
  add %o 1 try test.res.service.start.2 jz +1 set %p 1
  add %o 1 try test.res.service.start.3 jz +1 set %p 1

  add %o 1 try test.res.service.stop.1 jz +1 set %p 1
  add %o 1 try test.res.service.stop.2 jz +1 set %p 1
  add %o 1 try test.res.service.stop.3 jz +1 set %p 1

  add %o 1 try test.res.service.reload.1 jz +1 set %p 1
  add %o 1 try test.res.service.reload.2 jz +1 set %p 1
  add %o 1 try test.res.service.reload.3 jz +1 set %p 1
  add %o 1 try test.res.service.reload.4 jz +1 set %p 1

  add %o 1 try test.res.service.restart.1 jz +1 set %p 1
  add %o 1 try test.res.service.restart.2 jz +1 set %p 1
  add %o 1 try test.res.service.restart.3 jz +1 set %p 1
  add %o 1 try test.res.service.restart.4 jz +1 set %p 1

  add %o 1 try test.res.host.absent.1 jz +1 set %p 1
  add %o 1 try test.res.host.absent.2 jz +1 set %p 1
  add %o 1 try test.res.host.absent.3 jz +1 set %p 1

  add %o 1 try test.res.host.present.1 jz +1 set %p 1
  add %o 1 try test.res.host.present.2 jz +1 set %p 1
  add %o 1 try test.res.host.present.3 jz +1 set %p 1

  add %o 1 try test.res.host.aliases.1 jz +1 set %p 1
  add %o 1 try test.res.host.aliases.2 jz +1 set %p 1
  add %o 1 try test.res.host.aliases.3 jz +1 set %p 1
  add %o 1 try test.res.host.aliases.4 jz +1 set %p 1

  add %o 1 try test.res.package.absent.1 jz +1 set %p 1
  add %o 1 try test.res.package.absent.2 jz +1 set %p 1
  add %o 1 try test.res.package.absent.3 jz +1 set %p 1
  add %o 1 try test.res.package.absent.4 jz +1 set %p 1

  add %o 1 try test.res.package.install.1 jz +1 set %p 1
  add %o 1 try test.res.package.install.2 jz +1 set %p 1
  add %o 1 try test.res.package.install.3 jz +1 set %p 1
  add %o 1 try test.res.package.install.4 jz +1 set %p 1
  add %o 1 try test.res.package.install.5 jz +1 set %p 1
  add %o 1 try test.res.package.install.6 jz +1 set %p 1
  add %o 1 try test.res.package.install.7 jz +1 set %p 1
  add %o 1 try test.res.package.install.8 jz +1 set %p 1
  add %o 1 try test.res.package.install.9 jz +1 set %p 1
  add %o 1 try test.res.package.install.10 jz +1 set %p 1
  add %o 1 try test.res.package.install.11 jz +1 set %p 1
  add %o 1 try test.res.package.install.12 jz +1 set %p 1
  add %o 1 try test.res.package.install.13 jz +1 set %p 1

  geteuid %a
  eq %a 0 jz +2
    print "# skipping root tests\n"
    jmp noroot

ifroot:
  add %o 1 try test.res.chgrp.1 jz +1 set %p 1
  add %o 1 try test.res.chgrp.2 jz +1 set %p 1
  add %o 1 try test.res.chgrp.3 jz +1 set %p 1
  add %o 1 try test.res.chgrp.4 jz +1 set %p 1

  add %o 1 try test.res.chown.1 jz +1 set %p 1
  add %o 1 try test.res.chown.2 jz +1 set %p 1
  add %o 1 try test.res.chown.3 jz +1 set %p 1
  add %o 1 try test.res.chown.4 jz +1 set %p 1

  ;; for run(user|group), we need a real user and group
  ;; try nobody:nobody (redhat) or nobody:nogroup (debian)
  pragma authdb.root "/etc" authdb.open
  set %a "nobody"   user.find %a jnz skip-run-as user.get "uid" %c
  set %b "nobody"  group.find %b jz +3
  set %b "nogroup" group.find %b jnz skip-run-as group.get "gid" %d

  add %o 1 try test.res.run-as.1 jz +1 set %p 1
  add %o 1 try test.res.run-as.2 jz +1 set %p 1
  ;; back to root
  set %a "root" call util.runuser
                call util.rungroup
  jmp +1
skip-run-as:
  print "# skipping util.run* tests (couldn't find a suitable system user/group)\n"

  add %o 1 try test.res.user.mkhome.1 jz +1 set %p 1
  add %o 1 try test.res.user.mkhome.2 jz +1 set %p 1
  add %o 1 try test.res.user.mkhome.3 jz +1 set %p 1
  add %o 1 try test.res.user.mkhome.4 jz +1 set %p 1
  add %o 1 try test.res.user.mkhome.5 jz +1 set %p 1

noroot:
  exec "rm -rf t/tmp" %e
  print "1..%[o]i\n"
  retv %p

;; vim:et:ts=2
