%{
/*
  Copyright 2011-2014 James Hunt <james@jameshunt.us>

  This file is part of Clockwork.

  Clockwork is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  Clockwork is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with Clockwork.  If not, see <http://www.gnu.org/licenses/>.
 */

/**

  grammar.y - Reentrant (pure) Bison LALR Parser

  This file defines the productions necessary to interpret
  tokens found by the lexical analyzer, and subsquently build
  a valid abstract syntax tree to describe policy generators.

 */
#include "private.h"

#define YYERROR_VERBOSE
%}

/*
  To get a reentrant Bison parser, we have to use the special
  '%pure-parser' directive.  Documentation on the 'net seems to
  disagree about whether this should be %pure-parser (with a hyphen)
  or %pure_parser (with an underscore).

  I have found %pure-parser to work just fine.  JRH */
%pure-parser

/* Define the lexical tokens used by the grammar.
      These definitions will be available to the lexer via the
      grammar.h header file, which is generated by bison */ 
%token T_ECHO
%token T_KEYWORD_IF
%token T_KEYWORD_UNLESS
%token T_KEYWORD_ELSE
%token T_KEYWORD_ELSIF
%token T_KEYWORD_END
%token T_KEYWORD_IS
%token T_KEYWORD_NOT
%token T_OP_ASSIGN

/* These token definitions identify the expected type of the lvalue.
   The name 'string' comes from the union members of the YYSTYPE
   union, defined in private.h

   N.B.: I deliberately do not use the %union construct provided by
   bison, opting to define the union myself in private.h.  If one of
   the possible lvalue types is not a basic type (like char*, int, etc.)
   then lexer is required to include the necessary header files. */

%token <string> T_IDENTIFIER
%token <string> T_QSTRING
%token <string> T_LITERAL
%token <string> T_NUMERIC

/* Define the lvalue types of non-terminal productions.
   These definitions are necessary so that the $1..$n and $$ "magical"
   variables work in the generated C code. */
/*%type <node> definitions         /* AST_OP_PROG */
%type <tpl>   template
%type <tnode> echo
%type <tnode> expressions expression
%type <tnode> conditional conditional_test alt_condition
%type <tnode> literal reference assignment
%type <string> value

%{

#define TEMPLATE(ctx) (((template_parser_context*)ctx)->root)
#define NODE(op,d1,d2) (template_new_tnode(TEMPLATE(ctx), (op), (d1), (d2)))

%}

%%

template: expressions
		{ TEMPLATE(ctx)->root = $1; }
	;

expressions:
		{ $$ = NODE(TNODE_NOOP, NULL, NULL); }
	| expressions expression
		{ tnode_add($1, $2); }
	;

expression: echo
	  | literal
	  | conditional
	  | reference
	  | assignment
	  ;

echo: T_ECHO expression
		{ $$ = NODE(TNODE_ECHO, NULL, NULL);
		  tnode_add($$, $2); }
	;

literal: T_LITERAL
		{ $$ = NODE(TNODE_ECHO, NULL, NULL);
		  tnode_add($$, NODE(TNODE_VALUE, $1, NULL)); }
	| value
		{ $$ = NODE(TNODE_VALUE, $1, NULL); }
	;

value: T_QSTRING
		{ $$ = $1; }
	| T_NUMERIC
		{ $$ = $1; }
	;

conditional: T_KEYWORD_IF conditional_test expressions alt_condition
		{ tnode_add($2, $3);
		  tnode_add($2, $4);
		  $$ = $2; }
	| T_KEYWORD_UNLESS conditional_test expressions alt_condition
		{ tnode_add($2, $4);
		  tnode_add($2, $3);
		  $$ = $2; }
	;

alt_condition: T_KEYWORD_END
		{ $$ = NODE(TNODE_NOOP, NULL, NULL); }
	| T_KEYWORD_ELSE expressions T_KEYWORD_END
		{ $$ = $2; }
	| T_KEYWORD_ELSIF conditional_test expressions alt_condition
		{ tnode_add($2, $3);
		  tnode_add($2, $4);
		  $$ = $2; }
	;

conditional_test: T_IDENTIFIER T_KEYWORD_IS value
		{ $$ = NODE(TNODE_IF_EQ, $1, $3); }
	| T_IDENTIFIER T_KEYWORD_IS T_KEYWORD_NOT value
		{ $$ = NODE(TNODE_IF_NE, $1, $4); }
	;

reference: T_IDENTIFIER
		{ $$ = NODE(TNODE_REF, $1, NULL); }

assignment: T_IDENTIFIER T_OP_ASSIGN value
		{ $$ = NODE(TNODE_ASSIGN, $1, $3); }
	;
