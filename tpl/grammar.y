%{
/**

  grammar.y - Reentrant (pure) Bison LALR Parser

  This file defines the productions necessary to interpret
  tokens found by the lexical analyzer, and subsquently build
  a valid abstract syntax tree to describe policy generators.

 */
#include "private.h"

#define YYERROR_VERBOSE
%}

/*
  To get a reentrant Bison parser, we have to use the special
  '%pure-parser' directive.  Documentation on the 'net seems to
  disagree about whether this should be %pure-parser (with a hyphen)
  or %pure_parser (with an underscore).

  I have found %pure-parser to work just fine.  JRH */
%pure-parser

/* Define the lexical tokens used by the grammar.
      These definitions will be available to the lexer via the
      grammar.h header file, which is generated by bison */ 
%token T_ECHO
%token T_KEYWORD_IF
%token T_KEYWORD_UNLESS
%token T_KEYWORD_ELSE
%token T_KEYWORD_END
%token T_KEYWORD_IS
%token T_KEYWORD_NOT
%token T_KEYWORD_FOR
%token T_KEYWORD_IN

/* These token definitions identify the expected type of the lvalue.
   The name 'string' comes from the union members of the YYSTYPE
   union, defined in private.h

   N.B.: I deliberately do not use the %union construct provided by
   bison, opting to define the union myself in private.h.  If one of
   the possible lvalue types is not a basic type (like char*, int, etc.)
   then lexer is required to include the necessary header files. */

%token <string> T_IDENTIFIER
%token <string> T_QSTRING
%token <singlec> T_LITERAL
%token <string> T_NUMERIC

/* Define the lvalue types of non-terminal productions.
   These definitions are necessary so that the $1..$n and $$ "magical"
   variables work in the generated C code. */
/*%type <node> definitions         /* AST_OP_PROG */
%type <tpl>   template
%type <tnode> echo
%type <tnode> expressions expression
%type <tnode> for_loop conditional conditional_test
%type <tnode> literal reference
%type <string> value
%type <autostr> literals

%{

#define TEMPLATE(ctx) (((template_parser_context*)ctx)->root)
#define NODE(op,d1,d2) (template_new_tnode(TEMPLATE(ctx), (op), (d1), (d2)))

%}

%%

template:
		{ TEMPLATE(ctx) = template_new(); }
	| template expression
		{ tnode_add(TEMPLATE(ctx)->root, $2); }
	;

expressions:
		{ $$ = NODE(TNODE_NOOP, NULL, NULL); }
	| expressions expression
		{ tnode_add($1, $2); }
	;

expression: echo
	  | literal
	  | for_loop
	  | conditional
	  | reference
	  ;

echo: T_ECHO expression
		{ $$ = NODE(TNODE_ECHO, NULL, NULL);
		  tnode_add($$, $2); }
	;

literal: literals
		{ $$ = NODE(TNODE_ECHO, NULL, NULL);
		  tnode_add($$, NODE(TNODE_VALUE, xstrdup($1->data), NULL));
		  free($1->data);
		  free($1); }
	| value
		{ $$ = NODE(TNODE_VALUE, $1, NULL); }
	;

literals:
		{ $$ = xmalloc(sizeof(struct autostr));
		  $$->str_size = 0;
		  $$->buf_size = 128;
		  $$->data = xmalloc(sizeof(char) * $$->buf_size);
		  $$->tmp  = NULL;
		  $$->ptr  = $$->data;
		  *$$->ptr = '\0'; }
	| literals T_LITERAL
		{ if ($$->str_size == $$->buf_size - 1) {
			/* expand the buffer by 128 */
			$$->tmp = realloc($$->data, $$->buf_size + 128);
			if ($$->tmp) {
				$$->data = $$->tmp;
				$$->buf_size += 128;
			} else {
				/* FIXME: error and exit */
			}
		  }
		  *$$->ptr++ = $2;
		  $$->str_size++;
		  *$$->ptr = '\0'; }
	;

value: T_QSTRING
		{ $$ = $1; }
	;

for_loop: T_KEYWORD_FOR T_IDENTIFIER T_KEYWORD_IN T_IDENTIFIER expressions T_KEYWORD_END
		{ $$ = NODE(TNODE_FOR, $2, $4);
		  tnode_add($$, $5); }
	;

conditional: T_KEYWORD_IF conditional_test expressions T_KEYWORD_END
		{ tnode_add($2, $3);
		  tnode_add($2, NODE(TNODE_NOOP, NULL, NULL));
		  $$ = $2; }
	   | T_KEYWORD_IF conditional_test expressions T_KEYWORD_ELSE expressions T_KEYWORD_END
		{ tnode_add($2, $3);
		  tnode_add($2, $5);
		  $$ = $2; }
	   ;

conditional_test: T_IDENTIFIER T_KEYWORD_IS value
		{ $$ = NODE(TNODE_IF_EQ, $1, $3); }
		;

reference: T_IDENTIFIER
		{ $$ = NODE(TNODE_REF, $1, NULL); }
