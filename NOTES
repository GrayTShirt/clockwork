Locking System Accounts
-----------------------
User account locking seems to be accomplished via the standard passwd(1)
command by placing an exclamation point (!, 0x21) immediately before the
encrypted password in the /etc/shadow file.  Unlocking is done by removing
this exclamation point.  This method seems to be preferred because it
allows sysads to lock an account without losing the original password.

PWDB / SPDB - Remove List Head
------------------------------
Removing the list head (first entry in the database) currently presents a
few problems.  The caller has a pointer to the entry structure, so
stitching it out of the picture does not work.

Perhaps the best bet is to go back to pointers for payload (either struct
passwd * or struct spwd *) and set the pointer to NULL for all deleted
payloads (and free()ing memory accordingly).  Of course, the documentation
will have to warn callers that the second parameter passed to the pwdb_rm()
function will be freed, so that future usage results in undefined behavior.

SOLVED: The passwd member of struct pwdb is now a pointer
        The spwd member of struct spdb is now also a pointer

Object Lifecycle and Memory Management
--------------------------------------
The internal APIs between modules (stringlist, res_*, policy, etc.) need
to exhibit consistent behavior with respect to object (struct) creation,
initialization, and memory management.  To adhere to the Principle of
Least Surprise, the following conventions must be upheld:

int OBJECT_init(OBJECT*, ...)
	Initializes the members of the OBJECT with sane defaults
	Does not perform memmory allocation
	Returns non-zero if initialization fails
	Accepts other arguments for initialization, as needed

OBJECT* OBJECT_new(...)
	Dynamically allocates memory for an OBJECT
	Calls OBJECT_init to initialize the OBJECT
	Returns NULL if allocation or initialization fails
	Accepts the same arguments as OBJECT_init, for initialization

void OBJECT_deinit(OBJECT*)
	De-initializes members of OBJECT
	OBJECT is in an undefined state after this call

void OBJECT_free(OBJECT*)
	Calls OBJECT_deinit to de-initialize the OBJECT
	Frees dynamically allocated memory

These functions operate in pairs:
	OBJECT_init ----> (do stuff with object) ---> OBJECT_deinit
	OBJECT_new  ----> (do stuff with object) ---> OBJECT_free

Additionally, the following guidelines with respect to memory management
should be followed whenever possible, unless there is good reason not to.

 1. An object is responsible for all memory it allocates

	If a module (like stringlist) allocates an area of memory, either
	because it was asked to (stringlist_add) or as part of its integral
	operation, that module is responsible for freeing that memory.  It
	should not be left to the caller to fre memory allocated on their
	behalf.

 2. An object must not take responsibility for memory areas presented to
	it by callers.

	Callers should be able to live by guideline 1, above.  Ergo, modules
	should not take responsibility for memory away from a caller.  For
	example, stringlist_add takes a pointer to a null-terminated character
	array as its first argument, and adds it a list.  The module must
	allocate a copy of that string for storage in the stringlist struct,
	thereby leaving the caller responsible for the pointer they passed.

(These guidelines were laid down to maintain clearer code, and ensure that
memory leaks are easier to find, since responsibility for memory management
is clear and obvious.)

PACK As An Alternative to serializer/unserializer
-------------------------------------------------

The serializer / unserializer interface (serialize.o) is a bit clunky.  In
essence, it is a stupid string parser with some numeric conversion routines
built in.  The biggest problem is the workload placed on the user of the
serialize module; serialize knows nothing about the actual contents of a
serialized string, and the API forces the caller to build up or pull apart
a serialized representation by hand.

Let's take a lesson from the Perl playbook, and implement a (slightly) simpler
version of the pack / unpack pair of functions.  Variadic functions can be
made so that the API is familiar to C programmers used to printf and scanf.

Example: packing a res_user object ...

  if (pack("aaLLaaaCaCLLLLL",
           ru->ru_name, ru->ru_passwd, ru->uid, ru->gid,
           ru->gecos, ru->shell, ru->mkhome, ru->skel,
           ru->lock, ru->pwmin, ru->pwmax, ru->pwwarn,
           ru->inact, ru->expire) != 0) {

        return -1; /* some sort of failure code */
  }

... and then unpacking it ...

  if (unpack("aaLLaaaCaCLLLLL",
             &ru->ru_name, &ru->ru_passwd, &ru->uid, &ru->gid,
             &ru->gecos, &ru->shell, &ru->mkhome, &ru->skel,
             &ru->lock, &ru->pwmin, &ru->pwmax, &ru->pwwarn,
             &ru->inact, &ru->expire) != 0) {

        return -1; /* some sort of failure code */
  }

