#!/usr/bin/perl

our $FAILURES = 0;
our $TESTS = 0;
our $ASSERTIONS = 0;

sub finish_tests()
{
	print  "--------------------\n";
	print  "TEST RESULTS SUMMARY\n";
	print  "--------------------\n";
	printf("%4d test(s)\n", $TESTS);
	printf("%4d assertion(s)\n", $ASSERTIONS);
	print  "\n";
	printf("%4d FAILURES(s)\n", $FAILURES);

	exit ($FAILURES);
}

sub run($)
{
	my $command = shift;

	my $output = qx($command);
	chomp($output);

	return $output;
}

sub assert_str_equals($$$)
{
	(my $msg, my $expected, my $actual) = (@_);

	$ASSERTIONS++;

	if ($actual ne $expected) {
		print "$msg: FAIL\n";
		print "      actual:   '$actual' !=\n";
		print "      expected: '$expected'\n";
		$FAILURES++;
	}
}

sub assert_str_match($$$)
{
	(my $msg, my $regex, my $actual) = (@_);

	$ASSERTIONS++;

	if ($actual !~ m/($regex)/) {
		print "$msg: FAIL\n";
		print "      actual:   '$actual' !~ <regex> $regex\n";
		$FAILURES++;
	}
}

sub test_assertions()
{
	$TESTS++;
	print "test: assertion testing\n";

	assert_str_equals("  basic string equality assertions",
		"string value 42",
		"string value 42");

	assert_str_match("  basic string matching assertions",
		"ing [a-z]+ [0-9]+",
		"string value 42");
}

sub test_parser_inclusion()
{
	$TESTS++;
	print "parser: inclusion tests\n";

	my $includer = "./test/util/includer";
	my $root = "test/functional/includer";

	my $no_stderr = "2>/dev/null";
	my $stderr_only = "2>&1 >/dev/null";

	assert_str_equals("parser_incl: Duplicates", "duplicate",
		run(qq($includer "$root/dup.pol" $no_stderr)));

	assert_str_equals("parser_incl: Loop Detection", "b::a",
		run(qq($includer "$root/loop/a.pol" $no_stderr)));

	assert_str_equals("parser_incl: Glob Inclusion",
		"common::base-gentoo-dev::base-ubuntu-dev::base-gentoo-test::base-ubuntu-test",
		run(qq($includer "$root/glob-dev.pol" $no_stderr)));

	assert_str_match("parser_incl: Non-existent file inclusion",
		"error: can't stat .*: No such file or directory",
		run(qq($includer "$root/enoent.pol" $stderr_only)));

	assert_str_match("parser_incl: Inclusion of anything but regular files fails",
		"error: can't open /tmp/: not a regular file",
		run(qq($includer "$root/dir.pol" $stderr_only)));

	assert_str_match("parser_incl: Unterminated string literal in include statement",
		"warning: unterminated string literal",
		run(qq($includer "$root/unterminated.pol" $stderr_only)));

	assert_str_equals("parser_incl: Unterminated string literal works anyway", "simple",
		run(qq($includer "$root/unterminated.pol" $no_stderr)));

	assert_str_equals("parser_incl: Multi-level relative path resolution",
		"level2::level1::level0",
		run(qq($includer "$root/levels.pol" $no_stderr)));

}

sub test_fact_checking()
{
	$TESTS++;
	print "parser: fact checking (if and map)\n";

	my $factchecker = "./test/util/factchecker";
	my $root = "test/functional/factchecker";

	# if
	assert_str_equals("factchecker: [if] if branch followed", "res_user:jade-user:2125:3125",
		run(qq(echo "sys.hostname=jade" | $factchecker "$root/if.pol" 2>/dev/null)));

	assert_str_equals("factchecker: [if] else branch followed", "res_user:unknown:1500:1400",
		run(qq(echo "sys.hostname=quartz" | $factchecker "$root/if.pol" 2>/dev/null)));

	# if-list
	assert_str_equals("factchecker: [if-list] if branch followed for 'lucid'", "res_user:ubuntu:2125:3125",
		run(qq(echo "lsb.distro.codename=lucid" | $factchecker "$root/if-list.pol" 2>/dev/null)));

	assert_str_equals("factchecker: [if-list] if branch followed for 'karmic'", "res_user:ubuntu:2125:3125",
		run(qq(echo "lsb.distro.codename=karmic" | $factchecker "$root/if-list.pol" 2>/dev/null)));

	assert_str_equals("factchecker: [if-list] else branch followed for 'gentoo'", "res_user:other:2125:3125",
		run(qq(echo "lsb.distro.codename=gentoo" | $factchecker "$root/if-list.pol" 2>/dev/null)));

	# if-not
	assert_str_equals("factchecker: [if-not] if branch followed", "res_user:user:2125:3125",
		run(qq(echo "sys.hostname=topaz" | $factchecker "$root/if-not.pol" 2>/dev/null)));

	assert_str_equals("factchecker: [if-not] else branch followed", "res_user:jade-user:1500:1400",
		run(qq(echo "sys.hostname=jade" | $factchecker "$root/if-not.pol" 2>/dev/null)));

	# unless (syntactic sugar for if-not)
	assert_str_equals("factchecker: [unless] if branch followed", "res_user:user:2125:3125",
		run(qq(echo "sys.hostname=topaz" | $factchecker "$root/unless.pol" 2>/dev/null)));

	assert_str_equals("factchecker: [unless] else branch followed", "res_user:jade-user:1500:1400",
		run(qq(echo "sys.hostname=jade" | $factchecker "$root/unless.pol" 2>/dev/null)));

	# if-not-list
	assert_str_equals("factchecker: [if-not-list] else branch followed for 'lucid'", "res_user:ubuntu:2125:3125",
		run(qq(echo "lsb.distro.codename=lucid" | $factchecker "$root/if-not-list.pol" 2>/dev/null)));

	assert_str_equals("factchecker: [if-not-list] else branch followed for 'karmic'", "res_user:ubuntu:2125:3125",
		run(qq(echo "lsb.distro.codename=karmic" | $factchecker "$root/if-not-list.pol" 2>/dev/null)));

	assert_str_equals("factchecker: [if-not-list] if branch followed for 'intrepid'", "res_user:other:2125:3125",
		run(qq(echo "lsb.distro.codename=intrepid" | $factchecker "$root/if-list.pol" 2>/dev/null)));

	# if-only
	assert_str_equals("factchecker: [if-only] jade-user defined", "res_user:jade-user:2125:3125",
		run(qq(echo "sys.hostname=jade" | $factchecker "$root/if-only.pol" 2>/dev/null)));

	assert_str_equals("factchecker: [if-only] no users defined", "no users defined!",
		run(qq(echo "sys.hostname=emerald" | $factchecker "$root/if-only.pol" 2>/dev/null)));

	# unless-only
	assert_str_equals("factchecker: [unless-only] not-jade defined", "res_user:not-jade:2125:3125",
		run(qq(echo "sys.hostname=topaz" | $factchecker "$root/unless-only.pol" 2>/dev/null)));

	assert_str_equals("factchecker: [unless-only] no users defined", "no users defined!",
		run(qq(echo "sys.hostname=jade" | $factchecker "$root/unless-only.pol" 2>/dev/null)));

	# map
	assert_str_equals("factchecker: [map] UID is 2125 for fact '2xxx'", "res_user:guest:2125:3125",
		run(qq(echo "test.use_uid=2xxx" | $factchecker "$root/map.pol" 2>/dev/null)));

	assert_str_equals("factchecker: [map] UID is 3378 for fact '3xxx'", "res_user:guest:3378:3125",
		run(qq(echo "test.use_uid=3xxx" | $factchecker "$root/map.pol" 2>/dev/null)));

	assert_str_equals("factchecker: [map] UID is 4002 for fact '4xxx'", "res_user:guest:4002:3125",
		run(qq(echo "test.use_uid=4xxx" | $factchecker "$root/map.pol" 2>/dev/null)));

	assert_str_equals("factchecker: [map] UID is 999 for fact '1x'", "res_user:guest:999:3125",
		run(qq(echo "test.use_uid=1x" | $factchecker "$root/map.pol" 2>/dev/null)));

	# map-no-else
	assert_str_equals("factchecker: [map-no-else] UID is 2125 for fact '2xxx'", "res_user:guest:2125:3125",
		run(qq(echo "test.use_uid=2xxx" | $factchecker "$root/map-no-else.pol" 2>/dev/null)));

	assert_str_equals("factchecker: [map-no-else] UID is 3378 for fact '3xxx'", "res_user:guest:3378:3125",
		run(qq(echo "test.use_uid=3xxx" | $factchecker "$root/map-no-else.pol" 2>/dev/null)));

	assert_str_equals("factchecker: [map-no-else] UID is 0 (default) for fact '1x'", "res_user:guest:0:3125",
		run(qq(echo "test.use_uid=1x" | $factchecker "$root/map-no-else.pol" 2>/dev/null)));
}

sub test_overrides()
{
	$TESTS++;
	print "parser: resource overrides\n";

	my $checker = "echo \"sys.hostname=test\" | ./test/util/factchecker";
	my $root = "test/functional/overrides";

	assert_str_equals("overrides: user GID value overridden in same policy", "res_user:override:2125:3125",
		run(qq($checker "$root/same-policy.pol" 2>/dev/null)));

	assert_str_match("overrides: Same policy, but not in succession", "res_user:override:2125:3125",
		run(qq($checker "$root/same-interim.pol" 2>/dev/null)));

	assert_str_equals("overrides: UID value overridden from a different policy", "res_user:override:4815:100",
		run(qq($checker "$root/diff-policy.pol" 2>/dev/null)));
}

sub test_daemon_config()
{
	$TESTS++;
	print "config: basic parsing scenarios\n";

	my $checker = "./test/util/daemoncfg";
	my $root = "test/functional/daemoncfg";

	assert_str_equals("unable to parse non-existent file", "unable to parse file!",
		run(qq($checker "$root/enoent.conf" directive 2>/dev/null)));

	assert_str_equals("ca_cert_file should be parsed from the file", "/path/to/ca.pem",
		run(qq($checker "$root/good.conf" ca_cert_file 2>/dev/null)));

	assert_str_equals("ca_key_file should be parsed from the file", "/path/to/ca.key",
		run(qq($checker "$root/good.conf" ca_key_file 2>/dev/null)));

	assert_str_equals("port should be parsed from the file", "7890",
		run(qq($checker "$root/good.conf" port 2>/dev/null)));

	assert_str_equals("ca_key_file (w/unterm string literal) should be parsed from the file", "/path/to/ca.key",
		run(qq($checker "$root/unterm.conf" ca_key_file 2>/dev/null)));

	assert_str_match("errors for bad formats",
		"error: syntax error",
		run(qq($checker "$root/errors.conf" directive 2>&1 >/dev/null)));
}


test_assertions();
test_parser_inclusion();
test_fact_checking();
test_overrides();
test_daemon_config();
finish_tests();
