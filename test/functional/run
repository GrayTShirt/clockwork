#!/usr/bin/perl

use IO::Pipe;

our $FAILURES = 0;
our $TESTS = 0;
our $ASSERTIONS = 0;
our $TESTROOT = "test/functional";
our $DATAROOT = "$TESTROOT/data";

sub finish_tests()
{
	print  "--------------------\n";
	print  "TEST RESULTS SUMMARY\n";
	print  "--------------------\n";
	printf("%4d test(s)\n", $TESTS);
	printf("%4d assertion(s)\n", $ASSERTIONS);
	print  "\n";
	printf("%4d FAILURES(s)\n", $FAILURES);

	exit ($FAILURES);
}

sub run($)
{
	my $command = shift;

	my $output = qx($command);
	chomp($output);

	return $output;
}

sub assert_str_equals($$$)
{
	(my $msg, my $expected, my $actual) = (@_);

	$ASSERTIONS++;

	if ($actual ne $expected) {
		print "$msg: FAIL\n";
		print "      actual:   '$actual' !=\n";
		print "      expected: '$expected'\n";
		$FAILURES++;
	}
}

sub assert_str_match($$$)
{
	(my $msg, my $regex, my $actual) = (@_);

	$ASSERTIONS++;

	if ($actual !~ m/($regex)/) {
		print "$msg: FAIL\n";
		print "      actual:   '$actual' !~ <regex> $regex\n";
		$FAILURES++;
	}
}

sub assert_file_exists($$)
{
	(my $msg, my $file) = (@_);

	$ASSERTIONS++;

	if (! -f $file) {
		print "$msg: FAIL\n";
		print "      $file: no such file or directory\n";
		$FAILURES++;
	}
}

sub assert_file_not_exists($$)
{
	(my $msg, my $file) = (@_);

	$ASSERTIONS++;

	if (-f $file) {
		print "$msg: FAIL\n";
		print "      $file: is a file or directory\n";
		$FAILURES++;
	}
}

sub test_assertions()
{
	$TESTS++;
	print "test: assertion testing\n";

	assert_str_equals("  basic string equality assertions",
		"string value 42",
		"string value 42");

	assert_str_match("  basic string matching assertions",
		"ing [a-z]+ [0-9]+",
		"string value 42");

	my $f = "/tmp/tempf-CWTests";
	`touch $f`;
	assert_file_exists("  basic file existence assertion", $f);
	`rm -f $f`;
	assert_file_not_exists("  basic file non-existence assertion", $f);
}

sub test_parser_inclusion()
{
	$TESTS++;
	print "parser: inclusion tests\n";

	my $includer = "./$TESTROOT/includer";
	my $root = "$DATAROOT/includer";

	my $no_stderr = "2>/dev/null";
	my $stderr_only = "2>&1 >/dev/null";

	assert_str_equals("parser_incl: Duplicates", "duplicate",
		run(qq($includer "$root/dup.pol" $no_stderr)));

	assert_str_equals("parser_incl: Loop Detection", "b::a",
		run(qq($includer "$root/loop/a.pol" $no_stderr)));

	assert_str_equals("parser_incl: Glob Inclusion",
		"common::base-gentoo-dev::base-ubuntu-dev::base-gentoo-test::base-ubuntu-test",
		run(qq($includer "$root/glob-dev.pol" $no_stderr)));

	assert_str_equals("parser_incl: Non-existent first file inclusion",
		"unable to parse_file!",
		run(qq($includer "/no/such/file.pol" $no_stderr)));

	assert_str_match("parser_incl: Non-existent file inclusion",
		"error: can't stat .*: No such file or directory",
		run(qq($includer "$root/enoent.pol" $stderr_only)));

	assert_str_match("parser_incl: Inclusion of anything but regular files fails",
		"error: can't open /tmp/: not a regular file",
		run(qq($includer "$root/dir.pol" $stderr_only)));

	assert_str_match("parser_incl: Unterminated string literal in include statement",
		"warning: unterminated string literal",
		run(qq($includer "$root/unterminated.pol" $stderr_only)));

	assert_str_equals("parser_incl: Unterminated string literal works anyway", "simple",
		run(qq($includer "$root/unterminated.pol" $no_stderr)));

	assert_str_equals("parser_incl: Multi-level relative path resolution",
		"level2::level1::level0",
		run(qq($includer "$root/levels.pol" $no_stderr)));

}

sub test_fact_checking()
{
	$TESTS++;
	print "parser: fact checking (if and map)\n";

	my $factchecker = "./$TESTROOT/factchecker";
	my $root = "$DATAROOT/factchecker";

	# if
	assert_str_equals("factchecker: [if] if branch followed", "res_user:buildbox-user:2125:3125",
		run(qq(echo "sys.hostname=buildbox" | $factchecker "$root/if.pol" 2>/dev/null)));

	assert_str_equals("factchecker: [if] else branch followed", "res_user:unknown:1500:1400",
		run(qq(echo "sys.hostname=quartz" | $factchecker "$root/if.pol" 2>/dev/null)));

	# if-list
	assert_str_equals("factchecker: [if-list] if branch followed for 'lucid'", "res_user:ubuntu:2125:3125",
		run(qq(echo "lsb.distro.codename=lucid" | $factchecker "$root/if-list.pol" 2>/dev/null)));

	assert_str_equals("factchecker: [if-list] if branch followed for 'karmic'", "res_user:ubuntu:2125:3125",
		run(qq(echo "lsb.distro.codename=karmic" | $factchecker "$root/if-list.pol" 2>/dev/null)));

	assert_str_equals("factchecker: [if-list] else branch followed for 'gentoo'", "res_user:other:2125:3125",
		run(qq(echo "lsb.distro.codename=gentoo" | $factchecker "$root/if-list.pol" 2>/dev/null)));

	# if-not
	assert_str_equals("factchecker: [if-not] if branch followed", "res_user:user:2125:3125",
		run(qq(echo "sys.hostname=topaz" | $factchecker "$root/if-not.pol" 2>/dev/null)));

	assert_str_equals("factchecker: [if-not] else branch followed", "res_user:buildbox-user:1500:1400",
		run(qq(echo "sys.hostname=buildbox" | $factchecker "$root/if-not.pol" 2>/dev/null)));

	# unless (syntactic sugar for if-not)
	assert_str_equals("factchecker: [unless] if branch followed", "res_user:user:2125:3125",
		run(qq(echo "sys.hostname=topaz" | $factchecker "$root/unless.pol" 2>/dev/null)));

	assert_str_equals("factchecker: [unless] else branch followed", "res_user:buildbox-user:1500:1400",
		run(qq(echo "sys.hostname=buildbox" | $factchecker "$root/unless.pol" 2>/dev/null)));

	# if-not-list
	assert_str_equals("factchecker: [if-not-list] else branch followed for 'lucid'", "res_user:ubuntu:2125:3125",
		run(qq(echo "lsb.distro.codename=lucid" | $factchecker "$root/if-not-list.pol" 2>/dev/null)));

	assert_str_equals("factchecker: [if-not-list] else branch followed for 'karmic'", "res_user:ubuntu:2125:3125",
		run(qq(echo "lsb.distro.codename=karmic" | $factchecker "$root/if-not-list.pol" 2>/dev/null)));

	assert_str_equals("factchecker: [if-not-list] if branch followed for 'intrepid'", "res_user:other:2125:3125",
		run(qq(echo "lsb.distro.codename=intrepid" | $factchecker "$root/if-list.pol" 2>/dev/null)));

	# if-only
	assert_str_equals("factchecker: [if-only] buildbox-user defined", "res_user:buildbox-user:2125:3125",
		run(qq(echo "sys.hostname=buildbox" | $factchecker "$root/if-only.pol" 2>/dev/null)));

	assert_str_equals("factchecker: [if-only] no users defined", "no users defined!",
		run(qq(echo "sys.hostname=emerald" | $factchecker "$root/if-only.pol" 2>/dev/null)));

	# unless-only
	assert_str_equals("factchecker: [unless-only] not-buildbox defined", "res_user:not-buildbox:2125:3125",
		run(qq(echo "sys.hostname=topaz" | $factchecker "$root/unless-only.pol" 2>/dev/null)));

	assert_str_equals("factchecker: [unless-only] no users defined", "no users defined!",
		run(qq(echo "sys.hostname=buildbox" | $factchecker "$root/unless-only.pol" 2>/dev/null)));

	# map
	assert_str_equals("factchecker: [map] UID is 2125 for fact '2xxx'", "res_user:guest:2125:3125",
		run(qq(echo "test.use_uid=2xxx" | $factchecker "$root/map.pol" 2>/dev/null)));

	assert_str_equals("factchecker: [map] UID is 3378 for fact '3xxx'", "res_user:guest:3378:3125",
		run(qq(echo "test.use_uid=3xxx" | $factchecker "$root/map.pol" 2>/dev/null)));

	assert_str_equals("factchecker: [map] UID is 4002 for fact '4xxx'", "res_user:guest:4002:3125",
		run(qq(echo "test.use_uid=4xxx" | $factchecker "$root/map.pol" 2>/dev/null)));

	assert_str_equals("factchecker: [map] UID is 999 for fact '1x'", "res_user:guest:999:3125",
		run(qq(echo "test.use_uid=1x" | $factchecker "$root/map.pol" 2>/dev/null)));

	# map-no-else
	assert_str_equals("factchecker: [map-no-else] UID is 2125 for fact '2xxx'", "res_user:guest:2125:3125",
		run(qq(echo "test.use_uid=2xxx" | $factchecker "$root/map-no-else.pol" 2>/dev/null)));

	assert_str_equals("factchecker: [map-no-else] UID is 3378 for fact '3xxx'", "res_user:guest:3378:3125",
		run(qq(echo "test.use_uid=3xxx" | $factchecker "$root/map-no-else.pol" 2>/dev/null)));

	# 4294967295 is the unsigned representation of -1
	assert_str_equals("factchecker: [map-no-else] UID is 0 (default) for fact '1x'", "res_user:guest:4294967295:3125",
		run(qq(echo "test.use_uid=1x" | $factchecker "$root/map-no-else.pol" 2>/dev/null)));
}

sub test_overrides()
{
	$TESTS++;
	print "parser: resource overrides\n";

	my $checker = "echo \"sys.hostname=test\" | ./$TESTROOT/factchecker";
	my $root = "$DATAROOT/overrides";

	assert_str_equals("overrides: user GID value overridden in same policy", "res_user:override:2125:3125",
		run(qq($checker "$root/same-policy.pol" 2>/dev/null)));

	assert_str_match("overrides: Same policy, but not in succession", "res_user:override:2125:3125",
		run(qq($checker "$root/same-interim.pol" 2>/dev/null)));

	assert_str_equals("overrides: UID value overridden from a different policy", "res_user:override:4815:100",
		run(qq($checker "$root/diff-policy.pol" 2>/dev/null)));
}

sub test_daemon_config()
{
	$TESTS++;
	print "config: basic parsing scenarios\n";

	my $checker = "./$TESTROOT/daemoncfg";
	my $root = "$DATAROOT/daemoncfg";

	assert_str_equals("unable to parse non-existent file", "unable to parse file!",
		run(qq($checker "$root/enoent.conf" directive 2>/dev/null)));

	assert_str_equals("ca_cert_file should be parsed from the file", "/path/to/ca.pem",
		run(qq($checker "$root/good.conf" ca_cert_file 2>/dev/null)));

	assert_str_equals("ca_key_file should be parsed from the file", "/path/to/ca.key",
		run(qq($checker "$root/good.conf" ca_key_file 2>/dev/null)));

	assert_str_equals("port should be parsed from the file", "7890",
		run(qq($checker "$root/good.conf" port 2>/dev/null)));

	assert_str_equals("ca_key_file (w/unterm string literal) should be parsed from the file", "/path/to/ca.key",
		run(qq($checker "$root/unterm.conf" ca_key_file 2>/dev/null)));

	assert_str_match("errors for bad formats",
		"error: unexpected character",
		run(qq($checker "$root/errors.conf" directive 2>&1 >/dev/null)));
}

sub test_presence()
{
	$TESTS++;
	print "config: presence / absence\n";

	my $checker = "./$TESTROOT/presence";
	my $root = "$DATAROOT/presence";

	assert_str_equals("implicitly, users are defined as 'present'",
		"present:user1:user2:user3\nabsent:none",
		run(qq($checker "$root/implicit.conf" 2>/dev/null)));

	assert_str_equals("users can be set explicitly to 'absent'",
		"present:user1:user2\nabsent:missing1:missing2",
		run(qq($checker "$root/explicit.conf" 2>/dev/null)));

	assert_str_equals("presence can be overridden",
		"present:none\nabsent:override",
		run(qq($checker "$root/override-absent.conf" 2>/dev/null)));

	assert_str_equals("absence can be overridden",
		"present:override\nabsent:none",
		run(qq($checker "$root/override-present.conf" 2>/dev/null)));
}

sub _random_string($)
{
	my $n = shift;
	my $s = "";

	my @letters = split(//, "abcdefghijklmnopqrstuvwxyz0123456789 ");
	my $max = $#letters + 1;

	for ($i = 0; $i < $n; $i++) {
		$s .= $letters[rand($max)];
	}

	return $s;
}

sub test_prompter()
{
	$TESTS++;
	print "prompter: echo prompts\n";

	my $checker = "./$TESTROOT/prompter";
	my $str;

	for (my $i = 1; $i < 64; $i++) {
		$str = _random_string($i);
		assert_str_equals("Random string ($i bytes)",
		                  "$i:$str:", run(qq(echo "$str" | $checker 2>&1 >/dev/null)));
	}

}

sub test_executive()
{
	$TESTS++;
	print "executive: capture stdout\n";

	my $checker = "./$TESTROOT/executive";
	my $scripts = "./$DATAROOT/exec";

	assert_str_equals("Can capture both stdout and stderr",
		"STDOUT:this is standard output\nSTDERR:this is standard error",
		run(qq($checker both $scripts/test1)));

	assert_str_equals("Can capture stdout only",
		"STDOUT:this is standard output\nSTDERR:<not captured>",
		run(qq($checker stdout $scripts/test1)));

	assert_str_equals("Can capture stderr only",
		"STDOUT:<not captured>\nSTDERR:this is standard error",
		run(qq($checker stderr $scripts/test1)));

	assert_str_equals("Can suppress stdout and stderr",
		"STDOUT:<not captured>\nSTDERR:<not captured>",
		run(qq($checker none $scripts/test1)));
}

sub test_cwcert()
{
	$TESTS++;
	print "cwcert: certificate and key generation\n";

	my $hostname = `hostname -f`;

	my $key_f  = "test/functional/tmp/key.pem";
	my $cert_f = "test/functional/tmp/cert.pem";
	my $req_f  = "test/functional/tmp/request.pem";

	run(qq(rm -f $key_f $cert_f $req_f));
	assert_file_not_exists("Key does not exist initially", $key_f);
	assert_file_not_exists("Request does not exist initially", $req_f);
	assert_file_not_exists("Certificate does not exist initially", $cert_f);

	run(qq(expect -f $DATAROOT/cwcert/cwcert-new.expect "$hostname"));

	assert_file_exists("Key exists after `cwcert new`", $key_f);
	assert_file_exists("Request exists after `cwcert new`", $req_f);
	assert_file_not_exists("Certificate still doesn't exist (offline mode)", $cert_f);

	#`rm -f $key_f $cert_f $req_f`;
}



test_assertions();
test_parser_inclusion();
test_fact_checking();
test_overrides();
test_daemon_config();
test_presence();
test_prompter();
test_executive();
test_cwcert();
finish_tests();
